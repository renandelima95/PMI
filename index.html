<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARES - Cálculo de Dispersão e PMI</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            font-family: Helvetica, Arial, sans-serif;
        }
        body {
            background-color: #262626;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const ARES_LOGO = "./assets/Logo_Ares_1.png";

        // Tipos de alvo pré-definidos
        const TARGET_TYPES = {
            'otan_230': { name: 'OTAN 2,3m x 2,3m', width: 230, height: 230 },
            'otan_side': { name: 'OTAN Side 4,6m x 2,3m', width: 460, height: 230 },
            'a1_vert': { name: 'Folha A1 (Vertical)', width: 59.4, height: 84.1 },
            'a1_horiz': { name: 'Folha A1 (Horizontal)', width: 84.1, height: 59.4 },
            'custom': { name: 'Customizado', width: 230, height: 230 }
        };

        // Componente de simulação - SEMPRE usa OTAN 2,3x2,3m
        function DistanceSimulation({ distance, shots, results, currentDistance }) {
            const canvasRef = useRef(null);

            // Calcular missedShots fora do useEffect para usar no JSX
            const simulatedShots = shots.map(shot => {
                const angleXRad = Math.atan((shot.x / 100) / currentDistance);
                const angleYRad = Math.atan((shot.y / 100) / currentDistance);
                const newX = Math.tan(angleXRad) * distance * 100;
                const newY = Math.tan(angleYRad) * distance * 100;
                return { x: newX, y: newY };
            });

            const missedShots = simulatedShots.filter(shot => 
                Math.abs(shot.x) > 115 || Math.abs(shot.y) > 115
            ).length;

            useEffect(() => {
                if (!canvasRef.current || !results) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;

                const scale = width / 230; // OTAN padrão

                ctx.fillStyle = '#d0d0d0';
                ctx.fillRect(0, 0, width, height);

                // Desenhar alvo NATO
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(centerX, 0, width/2, height/2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width/2, height/2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, centerY, width/2, height/2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(centerX, centerY, width/2, height/2);

                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, height);
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();

                simulatedShots.forEach(shot => {
                    const x = centerX + shot.x * scale;
                    const y = centerY - shot.y * scale;
                    const isInside = Math.abs(shot.x) <= 115 && Math.abs(shot.y) <= 115;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fillStyle = isInside ? '#e74c3c' : '#FF6B6B';
                    ctx.fill();
                    ctx.strokeStyle = isInside ? '#c0392b' : '#FF0000';
                    ctx.lineWidth = isInside ? 1.5 : 2;
                    ctx.stroke();
                    
                    if (!isInside) {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x - 6, y - 6);
                        ctx.lineTo(x + 6, y + 6);
                        ctx.moveTo(x + 6, y - 6);
                        ctx.lineTo(x - 6, y + 6);
                        ctx.stroke();
                    }
                });

                const meanAngleXRad = Math.atan((results.meanX / 100) / currentDistance);
                const meanAngleYRad = Math.atan((results.meanY / 100) / currentDistance);
                const simMeanX = Math.tan(meanAngleXRad) * distance * 100;
                const simMeanY = Math.tan(meanAngleYRad) * distance * 100;
                
                const meanPixelX = centerX + simMeanX * scale;
                const meanPixelY = centerY - simMeanY * scale;
                
                ctx.beginPath();
                ctx.arc(meanPixelX, meanPixelY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = '#3498db';
                ctx.fill();
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 2;
                ctx.stroke();

            }, [distance, shots, results, currentDistance, simulatedShots]);

            return (
                <div className="bg-white p-4 rounded-xl border-2 border-gray-200">
                    <div className="text-center mb-2">
                        <span className="text-lg font-bold" style={{color: '#262626'}}>{distance}m</span>
                    </div>
                    <canvas 
                        ref={canvasRef} 
                        width={280} 
                        height={280} 
                        className="bg-white rounded-lg shadow-md mx-auto"
                        style={{maxWidth: '280px', width: '280px', height: '280px'}}
                    />
                    <div className="text-center mt-2">
                        <p className="text-xs text-gray-500">OTAN 2,3m x 2,3m</p>
                        <p className={`text-sm font-semibold ${missedShots > 0 ? 'text-red-600' : 'text-green-600'}`}>
                            {missedShots > 0 ? `${missedShots} disparo${missedShots > 1 ? 's' : ''} fora` : 'Todos dentro'}
                        </p>
                    </div>
                </div>
            );
        }

        // Componente principal
        function App() {
            const [distance, setDistance] = useState(100);
            const [shots, setShots] = useState([]);
            const [currentX, setCurrentX] = useState('');
            const [currentY, setCurrentY] = useState('');
            const canvasRef = useRef(null);
            
            // Tipo de alvo
            const [targetType, setTargetType] = useState('otan_230');
            const [customWidth, setCustomWidth] = useState(230);
            const [customHeight, setCustomHeight] = useState(230);
            
            const [uploadedImage, setUploadedImage] = useState(null);
            const [originalImageElement, setOriginalImageElement] = useState(null);
            const [calibrationMode, setCalibrationMode] = useState(false);
            const [calibrationStep, setCalibrationStep] = useState(0);
            const [calibrationPoints, setCalibrationPoints] = useState({
                center: null,
                top: null,
                bottom: null,
                left: null,
                right: null
            });
            const [isCalibrated, setIsCalibrated] = useState(false);
            const [clickMode, setClickMode] = useState(false);
            const [deleteMode, setDeleteMode] = useState(false);
            const imageCanvasRef = useRef(null);
            
            // Estados para Cenário de Teste
            const [sistema, setSistema] = useState(() => localStorage.getItem('cenario_sistema') || 'REMAX 3');
            const [sistemaOutro, setSistemaOutro] = useState('');
            const [sn, setSn] = useState('');
            const [armamento, setArmamento] = useState(() => localStorage.getItem('cenario_armamento') || '30mm');
            const [armamentoOutro, setArmamentoOutro] = useState('');
            const [condicoesTeste, setCondicoesTeste] = useState(() => localStorage.getItem('cenario_condicoes') || 'Estático');
            const [cenarioMovimento, setCenarioMovimento] = useState('');
            const [tipoMunicao, setTipoMunicao] = useState(() => localStorage.getItem('cenario_municao') || 'HEI');
            const [tipoDisparo, setTipoDisparo] = useState(() => localStorage.getItem('cenario_disparo') || 'Intermitente');
            const [qtdDisparos, setQtdDisparos] = useState('');
            const [modo, setModo] = useState('');
            const [gjIntermAz, setGjIntermAz] = useState('');
            const [gjIntermElv, setGjIntermElv] = useState('');
            const [gjRajadaAz, setGjRajadaAz] = useState('');
            const [gjRajadaElv, setGjRajadaElv] = useState('');
            
            // Carregar configurações do JSON
            const [config, setConfig] = useState({
                sistema: ["REMAX 3", "REMAX 4", "CORCED", "UT30BR", "UT30BR2", "Outro"],
                armamento: ["30mm", "12.7mm", "7.62mm", "Outro"],
                condicoes_teste: ["Estático", "Movimento"],
                tipo_disparo: ["Intermitente", "Rajada"],
                municao: {
                    "30mm": ["HEI", "HET", "APFDS"],
                    "12.7mm": ["Comum", "Traçante"],
                    "7.62mm": ["Comum", "Traçante"]
                }
            });
            
            useEffect(() => {
                fetch('./assets/config.json')
                    .then(res => res.json())
                    .then(data => setConfig(data))
                    .catch(err => {
                        console.warn('Não foi possível carregar config.json, usando valores padrão:', err);
                    });
            }, []);
            
            // Salvar seleções no localStorage
            useEffect(() => {
                localStorage.setItem('cenario_sistema', sistema);
            }, [sistema]);
            
            useEffect(() => {
                localStorage.setItem('cenario_armamento', armamento);
            }, [armamento]);
            
            useEffect(() => {
                localStorage.setItem('cenario_condicoes', condicoesTeste);
            }, [condicoesTeste]);
            
            useEffect(() => {
                localStorage.setItem('cenario_municao', tipoMunicao);
            }, [tipoMunicao]);
            
            useEffect(() => {
                localStorage.setItem('cenario_disparo', tipoDisparo);
            }, [tipoDisparo]);

            // Obter dimensões do alvo atual - MEMOIZADO para evitar loops
            const targetDims = useMemo(() => {
                if (targetType === 'custom') {
                    return { width: customWidth, height: customHeight };
                }
                return TARGET_TYPES[targetType];
            }, [targetType, customWidth, customHeight]);

            const halfWidth = targetDims.width / 2;
            const halfHeight = targetDims.height / 2;

            const calibrationSteps = [
                { key: 'center', label: 'Centro do alvo (0, 0)' },
                { key: 'top', label: `Topo do alvo (Y = +${halfHeight.toFixed(1)} cm)` },
                { key: 'bottom', label: `Base do alvo (Y = -${halfHeight.toFixed(1)} cm)` },
                { key: 'left', label: `Esquerda do alvo (X = -${halfWidth.toFixed(1)} cm)` },
                { key: 'right', label: `Direita do alvo (X = +${halfWidth.toFixed(1)} cm)` }
            ];

            // Calcular matriz de homografia (perspectiva)
            const calculateHomography = () => {
                if (!isCalibrated) return null;
                
                const { topLeft, topRight, bottomRight, bottomLeft } = calibrationPoints;
                
                // Pontos na imagem (origem)
                const srcPoints = [
                    [topLeft.x, topLeft.y],
                    [topRight.x, topRight.y],
                    [bottomRight.x, bottomRight.y],
                    [bottomLeft.x, bottomLeft.y]
                ];
                
                // Pontos no alvo real (destino) - em centímetros
                const dstPoints = [
                    [-halfWidth, halfHeight],   // top-left
                    [halfWidth, halfHeight],    // top-right
                    [halfWidth, -halfHeight],   // bottom-right
                    [-halfWidth, -halfHeight]   // bottom-left
                ];
                
                // Resolver sistema linear para encontrar matriz de homografia
                // Simplified Direct Linear Transformation (DLT)
                const A = [];
                for (let i = 0; i < 4; i++) {
                    const [x, y] = srcPoints[i];
                    const [X, Y] = dstPoints[i];
                    A.push([-x, -y, -1, 0, 0, 0, x*X, y*X, X]);
                    A.push([0, 0, 0, -x, -y, -1, x*Y, y*Y, Y]);
                }
                
                // Resolver Ah = 0 usando SVD simplificado
                // Para simplificar, vou usar método direto
                return { srcPoints, dstPoints };
            };

            const generatePDF = async () => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const results = calculateResults();
                
                if (!results) {
                    alert('Adicione disparos antes de gerar o PDF');
                    return;
                }

                // Header com cor #E5E6E7 (reduzido)
                doc.setFillColor(229, 230, 231);
                doc.rect(0, 0, 210, 25, 'F');
                
                doc.setTextColor(38, 38, 38);
                doc.setFontSize(14);
                doc.setFont('helvetica', 'bold');
                doc.text('Cálculo de Dispersão e PMI', 105, 12, { align: 'center' });
                
                const date = new Date().toLocaleString('pt-BR');
                doc.setFontSize(8);
                doc.setFont('helvetica', 'normal');
                doc.text(`Gerado em: ${date}`, 105, 19, { align: 'center' });
                
                doc.setTextColor(0, 0, 0);
                let yPos = 35;
                
                // Preparar valores para uso posterior (sempre exibir, mesmo se vazio)
                const sistemaText = sistema === 'Outro' ? (sistemaOutro || '-') : (sistema || '-');
                const snText = sn || '-';
                const armamentoText = armamento === 'Outro' ? (armamentoOutro || '-') : (armamento || '-');
                const municaoText = tipoMunicao || '-';
                const condicoesText = condicoesTeste || '-';
                const modoText = modo || '-';
                const disparoText = tipoDisparo || '-';
                const qtdText = qtdDisparos || '-';
                const gjIntermAzText = gjIntermAz || '-';
                const gjIntermElvText = gjIntermElv || '-';
                const gjRajadaAzText = gjRajadaAz || '-';
                const gjRajadaElvText = gjRajadaElv || '-';
                
                // Tabela de Disparos (página 1)
                doc.setFontSize(14);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(166, 168, 170);
                doc.text('Tabela de Disparos', 20, yPos);
                yPos += 7;
                
                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(0, 0, 0);
                doc.text(`Tipo de Alvo: ${TARGET_TYPES[targetType]?.name || 'Customizado'}`, 25, yPos);
                yPos += 5;
                doc.text(`Dimensões: ${targetDims.width.toFixed(1)}cm x ${targetDims.height.toFixed(1)}cm`, 25, yPos);
                yPos += 5;
                doc.text(`Distância: ${distance} m`, 25, yPos);
                yPos += 5;
                doc.text(`Disparos Registrados: ${shots.length}`, 25, yPos);
                yPos += 10;
                
                    // Tabela de Disparos
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(166, 168, 170);
                    doc.text('Disparos', 20, yPos);
                    yPos += 7;
                    
                    doc.setFillColor(229, 230, 231);
                    doc.rect(20, yPos - 5, 170, 8, 'F');
                    
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(0, 0, 0);
                    doc.text('#', 25, yPos);
                    doc.text('X(cm)', 45, yPos);
                    doc.text('Y(cm)', 70, yPos);
                    doc.text('X(mils)', 95, yPos);
                    doc.text('Y(mils)', 125, yPos);
                    yPos += 8;
                    
                    doc.setFont('helvetica', 'normal');
                    shots.forEach((shot, index) => {
                        const xMils = Math.atan((shot.x / 100) / distance) * 1000;
                        const yMils = Math.atan((shot.y / 100) / distance) * 1000;
                        
                        if (yPos > 270) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        doc.text(`${index + 1}`, 25, yPos);
                        doc.text(shot.x.toFixed(1), 45, yPos);
                        doc.text(shot.y.toFixed(1), 70, yPos);
                        doc.text(xMils.toFixed(2), 95, yPos);
                        doc.text(yMils.toFixed(2), 125, yPos);
                        yPos += 6;
                    });
                    
                    yPos += 8;
                    
                    // Resultados
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(166, 168, 170);
                    doc.text('Resultados', 20, yPos);
                    yPos += 10;
                    
                    doc.setFontSize(12);
                    doc.text('Ponto Médio', 25, yPos);
                    yPos += 7;
                    
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`X: ${results.meanX.toFixed(2)} cm | ${results.meanXMils.toFixed(2)} mils`, 30, yPos);
                    yPos += 6;
                    doc.text(`Y: ${results.meanY.toFixed(2)} cm | ${results.meanYMils.toFixed(2)} mils`, 30, yPos);
                    yPos += 10;
                    
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(166, 168, 170);
                    doc.text('Desvio Padrão', 25, yPos);
                    yPos += 7;
                    
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`Horizontal: ${results.stdDevXMils.toFixed(2)} mils`, 30, yPos);
                    yPos += 6;
                    doc.text(`Vertical: ${results.stdDevYMils.toFixed(2)} mils`, 30, yPos);
                    yPos += 6;
                    doc.text(`Radial: ${results.stdDevRadialMils.toFixed(2)} mils`, 30, yPos);
                    
                    // Visualização do Alvo + Simulações (mesma página)
                    if (canvasRef.current && shots.length > 0) {
                        doc.addPage();
                        doc.setFillColor(229, 230, 231);
                        doc.rect(0, 0, 210, 20, 'F');
                        doc.setTextColor(38, 38, 38);
                        doc.setFontSize(12);
                        doc.setFont('helvetica', 'bold');
                        doc.text('Visualização do Alvo e Simulações', 105, 12, { align: 'center' });
                        
                        let yPos2 = 25;
                        
                        // Cenário de Teste e Parâmetros (compactos em 2 colunas)
                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(166, 168, 170);
                        doc.text('Cenário de Teste', 15, yPos2);
                        doc.text('Parâmetros do Alvo', 110, yPos2);
                        yPos2 += 4;
                        
                        doc.setFontSize(7);
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(0, 0, 0);
                        
                        const col1X = 15;
                        const col2X = 110;
                        const lineHeight = 3;
                        let yLeft = yPos2;
                        let yRight = yPos2;
                        
                        // Coluna esquerda - Cenário de Teste
                        doc.text(`Sistema: ${sistemaText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`SN: ${snText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`Armamento: ${armamentoText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`Munição: ${municaoText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`Condições: ${condicoesText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`Modo: ${modoText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`Disparo: ${disparoText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`Qtd: ${qtdText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`GJ Int Az: ${gjIntermAzText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`GJ Int Elv: ${gjIntermElvText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`GJ Raj Az: ${gjRajadaAzText}`, col1X, yLeft);
                        yLeft += lineHeight;
                        doc.text(`GJ Raj Elv: ${gjRajadaElvText}`, col1X, yLeft);
                        
                        // Coluna direita - Parâmetros
                        doc.text(`Tipo: ${TARGET_TYPES[targetType]?.name || 'Custom'}`, col2X, yRight);
                        yRight += lineHeight;
                        doc.text(`Dimensões: ${targetDims.width.toFixed(1)} x ${targetDims.height.toFixed(1)} cm`, col2X, yRight);
                        yRight += lineHeight;
                        doc.text(`Distância: ${distance}m`, col2X, yRight);
                        
                        yPos2 = Math.max(yLeft, yRight) + 5;
                        
                        // Alvo principal (reduzido)
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(38, 38, 38);
                        doc.text(`Alvo Real - ${distance}m`, 105, yPos2, { align: 'center' });
                        yPos2 += 3;
                        
                        const imgData = canvasRef.current.toDataURL('image/png');
                        doc.addImage(imgData, 'PNG', 45, yPos2, 120, 120);
                        yPos2 += 125;
                        
                        // Status (Todos dentro / X disparos fora)
                        const shotsInside = shots.filter(shot => {
                            const halfWidth = targetDims.width / 2;
                            const halfHeight = targetDims.height / 2;
                            return Math.abs(shot.x) <= halfWidth && Math.abs(shot.y) <= halfHeight;
                        }).length;
                        const shotsOutside = shots.length - shotsInside;
                        
                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'normal');
                        if (shotsOutside > 0) {
                            doc.setTextColor(220, 38, 38);
                            doc.text(`${shotsOutside} disparo${shotsOutside > 1 ? 's' : ''} fora do alvo`, 105, yPos2, { align: 'center' });
                        } else {
                            doc.setTextColor(34, 139, 34);
                            doc.text('Todos os disparos dentro do alvo', 105, yPos2, { align: 'center' });
                        }
                        yPos2 += 5;
                        
                        // Resultados (PMI e Dispersão)
                        doc.setTextColor(38, 38, 38);
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'bold');
                        doc.text('Resultados', 105, yPos2, { align: 'center' });
                        yPos2 += 5;
                        // Calcular resultados
                        const avgX = shots.reduce((sum, s) => sum + s.x, 0) / shots.length;
                        const avgY = shots.reduce((sum, s) => sum + s.y, 0) / shots.length;
                        const pmiXMils = (Math.atan(avgX / 100 / distance) * 1000).toFixed(2);
                        const pmiYMils = (Math.atan(avgY / 100 / distance) * 1000).toFixed(2);
                        
                        const deviationsX = shots.map(s => s.x - avgX);
                        const deviationsY = shots.map(s => s.y - avgY);
                        const varianceX = deviationsX.reduce((sum, d) => sum + d * d, 0) / shots.length;
                        const varianceY = deviationsY.reduce((sum, d) => sum + d * d, 0) / shots.length;
                        const stdDevX = Math.sqrt(varianceX);
                        const stdDevY = Math.sqrt(varianceY);
                        const stdDevXMils = (Math.atan(stdDevX / 100 / distance) * 1000).toFixed(2);
                        const stdDevYMils = (Math.atan(stdDevY / 100 / distance) * 1000).toFixed(2);
                        
                        // Duas colunas de resultados
                        doc.setFontSize(7);
                        doc.setFont('helvetica', 'normal');
                        
                        // Coluna 1 - PMI
                        const col1XR = 40;
                        let yPosR = yPos2;
                        
                        doc.setFont('helvetica', 'bold');
                        doc.text('PMI', col1XR, yPosR);
                        yPosR += 3;
                        
                        doc.setFont('helvetica', 'normal');
                        doc.text(`Horiz: ${pmiXMils} mils`, col1XR, yPosR);
                        yPosR += 3;
                        doc.text(`Vert: ${pmiYMils} mils`, col1XR, yPosR);
                        
                        // Coluna 2 - Dispersão
                        const col2XR = 120;
                        yPosR = yPos2;
                        
                        doc.setFont('helvetica', 'bold');
                        doc.text('Dispersão', col2XR, yPosR);
                        yPosR += 3;
                        
                        doc.setFont('helvetica', 'normal');
                        doc.text(`Horiz: ${stdDevXMils} mils`, col2XR, yPosR);
                        yPosR += 3;
                        doc.text(`Vert: ${stdDevYMils} mils`, col2XR, yPosR);
                        
                        yPos2 = yPosR + 5;
                        
                        // Simulações (4 pequenas abaixo)
                        doc.setTextColor(38, 38, 38);
                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'bold');
                        doc.text('Simulações (OTAN 2,3m x 2,3m)', 105, yPos2, { align: 'center' });
                        yPos2 += 3;
                        
                        // Renderizar cada simulação
                        const distances = [100, 500, 1000, 1500];
                        const positions = [
                            { x: 10, y: yPos2 },   // 100m
                            { x: 60, y: yPos2 },   // 500m
                            { x: 110, y: yPos2 },  // 1000m
                            { x: 160, y: yPos2 }   // 1500m
                        ];
                        
                        distances.forEach((dist, index) => {
                            const pos = positions[index];
                            
                            // Criar canvas temporário para a simulação
                            const simCanvas = document.createElement('canvas');
                            simCanvas.width = 300;
                            simCanvas.height = 300;
                            const ctx = simCanvas.getContext('2d');
                            
                            // Fundo branco
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, 300, 300);
                            
                            // Configurações do alvo OTAN 2,3m x 2,3m
                            const scale = 300 / 230; // pixels por cm
                            const centerX = 150;
                            const centerY = 150;
                            const targetWidth = 230 * scale;
                            const targetHeight = 230 * scale;
                            const left = centerX - targetWidth / 2;
                            const top = centerY - targetHeight / 2;
                            
                            // Desenhar alvo OTAN (padrão quadriculado xadrez 2x2)
                            // Superior direito - Branco
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(centerX, top, targetWidth/2, targetHeight/2);
                            
                            // Superior esquerdo - Preto
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(left, top, targetWidth/2, targetHeight/2);
                            
                            // Inferior esquerdo - Branco  
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(left, centerY, targetWidth/2, targetHeight/2);
                            
                            // Inferior direito - Preto
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(centerX, centerY, targetWidth/2, targetHeight/2);
                            
                            // Borda do alvo
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(left, top, targetWidth, targetHeight);
                            
                            // Linhas de centro vermelhas
                            ctx.strokeStyle = '#FF0000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(centerX, top);
                            ctx.lineTo(centerX, top + targetHeight);
                            ctx.moveTo(left, centerY);
                            ctx.lineTo(left + targetWidth, centerY);
                            ctx.stroke();
                            
                            // Calcular e desenhar disparos simulados
                            let shotsInsideSim = 0;
                            shots.forEach(shot => {
                                const angleXRad = Math.atan((shot.x / 100) / distance);
                                const angleYRad = Math.atan((shot.y / 100) / distance);
                                const newX = Math.tan(angleXRad) * dist * 100;
                                const newY = Math.tan(angleYRad) * dist * 100;
                                
                                const x = centerX + newX * scale;
                                const y = centerY - newY * scale;
                                const isInside = Math.abs(newX) <= 115 && Math.abs(newY) <= 115;
                                
                                if (isInside) shotsInsideSim++;
                                
                                ctx.beginPath();
                                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                                ctx.fillStyle = isInside ? '#e74c3c' : '#FF6B6B';
                                ctx.fill();
                                ctx.strokeStyle = isInside ? '#c0392b' : '#FF0000';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                            });
                            
                            // Adicionar simulação ao PDF
                            const simData = simCanvas.toDataURL('image/png');
                            doc.addImage(simData, 'PNG', pos.x, pos.y, 45, 45);
                            
                            // Label da distância
                            doc.setFontSize(9);
                            doc.setFont('helvetica', 'bold');
                            doc.setTextColor(38, 38, 38);
                            doc.text(`${dist}m`, pos.x + 22.5, pos.y + 48, { align: 'center' });
                            
                            // Status da simulação
                            const shotsOutsideSim = shots.length - shotsInsideSim;
                            doc.setFontSize(7);
                            doc.setFont('helvetica', 'normal');
                            if (shotsOutsideSim > 0) {
                                doc.setTextColor(220, 38, 38);
                                doc.text(`${shotsOutsideSim} fora`, pos.x + 22.5, pos.y + 53, { align: 'center' });
                            } else {
                                doc.setTextColor(34, 139, 34);
                                doc.text('Todos dentro', pos.x + 22.5, pos.y + 53, { align: 'center' });
                            }
                        });
                    }
                    
                    // Foto do Alvo (original e com marcações)
                    if (uploadedImage) {
                        doc.addPage();
                        doc.setFillColor(229, 230, 231);
                        doc.rect(0, 0, 210, 35, 'F');
                        doc.setTextColor(38, 38, 38);
                        doc.setFontSize(16);
                        doc.setFont('helvetica', 'bold');
                        doc.text('Foto do Alvo', 105, 20, { align: 'center' });
                        
                        // Foto original (sem marcações) - usar diretamente o data URL
                        doc.setFontSize(11);
                        doc.setFont('helvetica', 'normal');
                        doc.text('Original', 55, 45, { align: 'center' });
                        doc.addImage(uploadedImage, 'PNG', 15, 50, 85, 85);
                        
                        // Foto com marcações
                        if (imageCanvasRef.current) {
                            doc.text('Com Marcações', 155, 45, { align: 'center' });
                            const photoData = imageCanvasRef.current.toDataURL('image/png');
                            doc.addImage(photoData, 'PNG', 110, 50, 85, 85);
                        }
                    }
                    
                    // Footer
                    const pageCount = doc.internal.getNumberOfPages();
                    for (let i = 1; i <= pageCount; i++) {
                        doc.setPage(i);
                        doc.setFillColor(38, 38, 38);
                        doc.rect(0, 287, 210, 10, 'F');
                        doc.setTextColor(229, 230, 231);
                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'normal');
                        doc.text('ARES - Tecnologia Brasileira em Defesa', 105, 293, { align: 'center' });
                    }
                    
                    doc.save(`ARES_Calculo_Dispersao_PMI_${Date.now()}.pdf`);
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            setUploadedImage(event.target.result); // Guardar data URL
                            setOriginalImageElement(img); // Guardar elemento de imagem
                            setCalibrationMode(true);
                            setCalibrationStep(0);
                            setCalibrationPoints({
                                center: null,
                                top: null,
                                bottom: null,
                                left: null,
                                right: null
                            });
                            setIsCalibrated(false);
                            setClickMode(false);
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleImageClick = (e) => {
                if (!imageCanvasRef.current) return;
                
                const canvas = imageCanvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                if (calibrationMode && calibrationStep < 5) {
                    const currentKey = calibrationSteps[calibrationStep].key;
                    setCalibrationPoints(prev => ({
                        ...prev,
                        [currentKey]: { x, y }
                    }));
                    
                    if (calibrationStep === 4) {
                        setCalibrationMode(false);
                        setIsCalibrated(true);
                        setClickMode(true);
                    } else {
                        setCalibrationStep(calibrationStep + 1);
                    }
                } else if (clickMode && isCalibrated) {
                    if (deleteMode) {
                        // Modo apagar - remover disparo mais próximo
                        const { center, top, bottom, left, right } = calibrationPoints;
                        const scaleYCoord = (bottom.y - top.y) / targetDims.height;
                        const scaleXCoord = (right.x - left.x) / targetDims.width;

                        let closestIndex = -1;
                        let minDistance = Infinity;

                        shots.forEach((shot, index) => {
                            const pixelX = center.x + (shot.x * scaleXCoord);
                            const pixelY = center.y - (shot.y * scaleYCoord);
                            
                            const distance = Math.sqrt(
                                Math.pow(x - pixelX, 2) + Math.pow(y - pixelY, 2)
                            );
                            
                            if (distance < minDistance && distance < 30) { // Raio de 30 pixels para touch
                                minDistance = distance;
                                closestIndex = index;
                            }
                        });

                        if (closestIndex !== -1) {
                            setShots(shots.filter((_, i) => i !== closestIndex));
                            setDeleteMode(false); // Desativar modo apagar após deletar
                        }
                    } else {
                        // Modo adicionar - adicionar novo disparo
                        const coords = pixelToCoordinates(x, y);
                        if (coords) {
                            setShots([...shots, coords]);
                        }
                    }
                }
            };

            const handleImageRightClick = (e) => {
                e.preventDefault(); // Prevenir menu de contexto
                
                if (!imageCanvasRef.current || !isCalibrated || shots.length === 0) return;
                
                const canvas = imageCanvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = (e.clientX - rect.left) * scaleX;
                const clickY = (e.clientY - rect.top) * scaleY;

                // Encontrar o disparo mais próximo do clique
                const { center, top, bottom, left, right } = calibrationPoints;
                const scaleYCoord = (bottom.y - top.y) / targetDims.height;
                const scaleXCoord = (right.x - left.x) / targetDims.width;

                let closestIndex = -1;
                let minDistance = Infinity;

                shots.forEach((shot, index) => {
                    const pixelX = center.x + (shot.x * scaleXCoord);
                    const pixelY = center.y - (shot.y * scaleYCoord);
                    
                    const distance = Math.sqrt(
                        Math.pow(clickX - pixelX, 2) + Math.pow(clickY - pixelY, 2)
                    );
                    
                    if (distance < minDistance && distance < 20) { // Raio de 20 pixels
                        minDistance = distance;
                        closestIndex = index;
                    }
                });

                if (closestIndex !== -1) {
                    // Remover o disparo mais próximo
                    setShots(shots.filter((_, i) => i !== closestIndex));
                }
            };

            const pixelToCoordinates = (pixelX, pixelY) => {
                if (!isCalibrated) return null;

                const { center, top, bottom, left, right } = calibrationPoints;
                const totalHeight = targetDims.height;
                const totalWidth = targetDims.width;
                
                const scaleY = (bottom.y - top.y) / totalHeight;
                const scaleX = (right.x - left.x) / totalWidth;
                const deltaX = pixelX - center.x;
                const deltaY = center.y - pixelY;
                const x = deltaX / scaleX;
                const y = deltaY / scaleY;

                return { x, y };
            };

            const drawImageCanvas = () => {
                try {
                    console.log('drawImageCanvas called');
                    if (!imageCanvasRef.current || !originalImageElement) {
                        console.log('No canvas or image');
                        return;
                    }

                    const canvas = imageCanvasRef.current;
                    const ctx = canvas.getContext('2d');

                    const maxWidth = Math.min(window.innerWidth - 40, 800);
                    const maxHeight = Math.min(window.innerHeight * 0.6, 600);
                    let width = originalImageElement.width;
                    let height = originalImageElement.height;

                    if (width > maxWidth || height > maxHeight) {
                        const ratio = Math.min(maxWidth / width, maxHeight / height);
                        width *= ratio;
                        height *= ratio;
                    }

                    canvas.width = width;
                    canvas.height = height;

                    ctx.drawImage(originalImageElement, 0, 0, width, height);

                    ctx.strokeStyle = '#00FF00';
                    ctx.fillStyle = '#00FF00';
                    ctx.lineWidth = 3;

                    Object.entries(calibrationPoints).forEach(([key, point]) => {
                        if (point) {
                            // Apenas cruz (sem círculo)
                            ctx.strokeStyle = '#00FF00';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(point.x - 10, point.y);
                            ctx.lineTo(point.x + 10, point.y);
                            ctx.moveTo(point.x, point.y - 10);
                            ctx.lineTo(point.x, point.y + 10);
                            ctx.stroke();

                            ctx.fillStyle = '#FFFFFF';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.font = 'bold 12px Arial';
                            const labels = {
                                center: 'C',
                                top: 'T',
                                bottom: 'B',
                                left: 'E',
                                right: 'D'
                            };
                            const label = labels[key] || key.substring(0, 1).toUpperCase();
                            ctx.strokeText(label, point.x + 15, point.y - 10);
                            ctx.fillStyle = '#00FF00';
                            ctx.fillText(label, point.x + 15, point.y - 10);
                        }
                    });

                    console.log('Drawing shots:', shots.length);
                    if (isCalibrated && shots.length > 0) {
                        shots.forEach((shot, index) => {
                            console.log(`Drawing shot ${index}:`, shot);
                            const { center, top, bottom, left, right } = calibrationPoints;
                            
                            const scaleY = (bottom.y - top.y) / targetDims.height;
                            const scaleX = (right.x - left.x) / targetDims.width;
                            
                            const pixelX = center.x + (shot.x * scaleX);
                            const pixelY = center.y - (shot.y * scaleY);

                            ctx.fillStyle = '#FF0000';
                            ctx.strokeStyle = '#8B0000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(pixelX, pixelY, 8, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        });
                    }
                    console.log('drawImageCanvas completed');
                } catch (error) {
                    console.error('Error in drawImageCanvas:', error);
                }
            };

            useEffect(() => {
                console.log('useEffect triggered - originalImageElement:', !!originalImageElement, 'shots:', shots.length);
                if (originalImageElement) {
                    drawImageCanvas();
                }
            }, [originalImageElement, calibrationPoints, shots, isCalibrated, targetDims]);

            const resetCalibration = () => {
                setUploadedImage(null);
                setCalibrationMode(false);
                setCalibrationStep(0);
                setCalibrationPoints({
                    center: null,
                    top: null,
                    bottom: null,
                    left: null,
                    right: null
                });
                setIsCalibrated(false);
                setClickMode(false);
            };

            const addShot = () => {
                if (currentX !== '' && currentY !== '') {
                    setShots([...shots, { x: parseFloat(currentX), y: parseFloat(currentY) }]);
                    setCurrentX('');
                    setCurrentY('');
                }
            };

            const removeShot = (index) => {
                setShots(shots.filter((_, i) => i !== index));
            };

            const clearAll = () => {
                setShots([]);
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter') {
                    addShot();
                }
            };

            const calculateResults = () => {
                if (shots.length === 0) return null;

                const meanX = shots.reduce((sum, shot) => sum + shot.x, 0) / shots.length;
                const meanY = shots.reduce((sum, shot) => sum + shot.y, 0) / shots.length;

                const angleXRadians = Math.atan((meanX / 100) / distance);
                const angleYRadians = Math.atan((meanY / 100) / distance);
                
                const meanXMils = angleXRadians * 1000;
                const meanYMils = angleYRadians * 1000;

                const n = shots.length;
                const varianceX = shots.reduce((sum, shot) => sum + Math.pow(shot.x - meanX, 2), 0) / (n - 1);
                const varianceY = shots.reduce((sum, shot) => sum + Math.pow(shot.y - meanY, 2), 0) / (n - 1);
                const stdDevX = Math.sqrt(varianceX);
                const stdDevY = Math.sqrt(varianceY);

                const radialDistances = shots.map(shot => 
                    Math.sqrt(Math.pow(shot.x - meanX, 2) + Math.pow(shot.y - meanY, 2))
                );
                const varianceRadial = radialDistances.reduce((sum, d) => sum + Math.pow(d - (radialDistances.reduce((s, v) => s + v, 0) / n), 2), 0) / (n - 1);
                const stdDevRadial = Math.sqrt(varianceRadial);
                
                const stdDevXMils = Math.atan((stdDevX / 100) / distance) * 1000;
                const stdDevYMils = Math.atan((stdDevY / 100) / distance) * 1000;
                const stdDevRadialMils = Math.atan((stdDevRadial / 100) / distance) * 1000;

                return {
                    meanX,
                    meanY,
                    meanXMils,
                    meanYMils,
                    stdDevX,
                    stdDevY,
                    stdDevXMils,
                    stdDevYMils,
                    stdDevRadialMils
                };
            };

            const results = calculateResults();

            // Desenhar alvo principal
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Escala baseada nas dimensões do alvo
                const maxDim = Math.max(targetDims.width, targetDims.height);
                const scale = (width * 0.9) / maxDim;

                ctx.fillStyle = '#d0d0d0';
                ctx.fillRect(0, 0, width, height);

                const targetWidth = targetDims.width * scale;
                const targetHeight = targetDims.height * scale;
                const left = centerX - targetWidth / 2;
                const top = centerY - targetHeight / 2;

                // Desenhar padrão do alvo conforme tipo
                if (targetType === 'a1_vert' || targetType === 'a1_horiz') {
                    // Alvo A1 com dimensões específicas
                    // Fundo branco
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(left, top, targetWidth, targetHeight);
                    
                    // Desenhar quadriculado fino de 10mm (1cm)
                    const gridSizeFine = 1 * scale; // 10mm = 1cm
                    ctx.strokeStyle = '#CCCCCC';
                    ctx.lineWidth = 0.5;
                    
                    // Ajustar início para que o centro esteja em um vértice
                    const startX = centerX % gridSizeFine;
                    const startY = centerY % gridSizeFine;
                    
                    // Linhas verticais finas
                    for (let x = startX; x < width; x += gridSizeFine) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    
                    // Linhas horizontais finas
                    for (let y = startY; y < height; y += gridSizeFine) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                    
                    // Desenhar quadriculado grosso de 100mm (10cm)
                    const gridSizeThick = 10 * scale; // 100mm = 10cm
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1.5;
                    
                    // Linhas verticais grossas (centro no vértice)
                    for (let x = centerX; x < width; x += gridSizeThick) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    for (let x = centerX - gridSizeThick; x >= 0; x -= gridSizeThick) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    
                    // Linhas horizontais grossas (centro no vértice)
                    for (let y = centerY; y < height; y += gridSizeThick) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                    for (let y = centerY - gridSizeThick; y >= 0; y -= gridSizeThick) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                    
                    // Quadrado de 230mm (23cm)
                    const squareSize = 23 * scale;
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(centerX - squareSize/2, centerY - squareSize/2, 
                                   squareSize, squareSize);
                    
                    // Círculo de 200mm (20cm) de diâmetro
                    const outerRadius = 10 * scale; // raio = 100mm = 10cm
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    // Círculo central preto de 60mm (6cm) de diâmetro
                    const innerRadius = 3 * scale; // raio = 30mm = 3cm
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    // Alvo NATO padrão (quadriculado)
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(centerX, top, targetWidth/2, targetHeight/2);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(left, top, targetWidth/2, targetHeight/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(left, centerY, targetWidth/2, targetHeight/2);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX, centerY, targetWidth/2, targetHeight/2);
                }

                // Eixos
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, top);
                ctx.lineTo(centerX, top + targetHeight);
                ctx.moveTo(left, centerY);
                ctx.lineTo(left + targetWidth, centerY);
                ctx.stroke();

                // Desenhar disparos
                shots.forEach(shot => {
                    const x = centerX + shot.x * scale;
                    const y = centerY - shot.y * scale;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#e74c3c';
                    ctx.fill();
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // Ponto médio
                if (results) {
                    const meanX = centerX + results.meanX * scale;
                    const meanY = centerY - results.meanY * scale;
                    
                    ctx.beginPath();
                    ctx.arc(meanX, meanY, 10, 0, 2 * Math.PI);
                    ctx.fillStyle = '#3498db';
                    ctx.fill();
                    ctx.strokeStyle = '#2980b9';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

            }, [shots, results, targetType, customWidth, customHeight]);

            return (
                <div className="min-h-screen" style={{backgroundColor: '#262626'}}>
                    <div className="max-w-7xl mx-auto p-2 sm:p-4">
                        <div className="bg-white rounded-2xl shadow-2xl overflow-hidden">
                            <div style={{backgroundColor: '#E5E6E7'}} className="p-4 sm:p-8 text-center">
                                <div className="flex items-center justify-center mb-2 sm:mb-4">
                                    <img src={ARES_LOGO} alt="ARES Logo" className="h-24 sm:h-40"/>
                                </div>
                                <h1 className="text-2xl sm:text-4xl font-bold" style={{color: '#262626'}}>Cálculo de Dispersão e PMI</h1>
                            </div>

                            <div className="p-3 sm:p-8">
                                {/* Seção Cenário de Teste */}
                                <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200 mb-4 sm:mb-8">
                                    <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                        Cenário de Teste
                                    </h2>
                                    
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        {/* Linha 1: Sistema | SN */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Sistema</label>
                                            <select
                                                value={sistema}
                                                onChange={(e) => setSistema(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            >
                                                {config.sistema.map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                            {sistema === 'Outro' && (
                                                <input
                                                    type="text"
                                                    value={sistemaOutro}
                                                    onChange={(e) => setSistemaOutro(e.target.value)}
                                                    placeholder="Especifique o sistema"
                                                    className="w-full p-2 border border-gray-300 rounded mt-2"
                                                />
                                            )}
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">SN</label>
                                            <input
                                                type="text"
                                                value={sn}
                                                onChange={(e) => setSn(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                        {/* Linha 2: Armamento | Munição */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Armamento</label>
                                            <select
                                                value={armamento}
                                                onChange={(e) => {
                                                    setArmamento(e.target.value);
                                                    if (e.target.value !== 'Outro' && config.municao[e.target.value]) {
                                                        setTipoMunicao(config.municao[e.target.value][0]);
                                                    }
                                                }}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            >
                                                {config.armamento.map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                            {armamento === 'Outro' && (
                                                <input
                                                    type="text"
                                                    value={armamentoOutro}
                                                    onChange={(e) => setArmamentoOutro(e.target.value)}
                                                    placeholder="Especifique o armamento"
                                                    className="w-full p-2 border border-gray-300 rounded mt-2"
                                                />
                                            )}
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Munição</label>
                                            <select
                                                value={tipoMunicao}
                                                onChange={(e) => setTipoMunicao(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                                disabled={armamento === 'Outro'}
                                            >
                                                {armamento !== 'Outro' && config.municao[armamento] && config.municao[armamento].map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                        </div>
                                        
                                        {/* Linha 3: Condições de Teste | Modo */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Condições de Teste</label>
                                            <select
                                                value={condicoesTeste}
                                                onChange={(e) => setCondicoesTeste(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            >
                                                {config.condicoes_teste.map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                            {condicoesTeste === 'Movimento' && (
                                                <textarea
                                                    value={cenarioMovimento}
                                                    onChange={(e) => setCenarioMovimento(e.target.value)}
                                                    placeholder="Descreva o cenário de movimento"
                                                    className="w-full p-2 border border-gray-300 rounded mt-2"
                                                    rows="2"
                                                />
                                            )}
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Modo</label>
                                            <input
                                                type="text"
                                                value={modo}
                                                onChange={(e) => setModo(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                        {/* Linha 4: Tipo de Disparo | Quantidade Total de Disparos */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Tipo de Disparo</label>
                                            <select
                                                value={tipoDisparo}
                                                onChange={(e) => setTipoDisparo(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            >
                                                {config.tipo_disparo.map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Quantidade Total de Disparos</label>
                                            <input
                                                type="text"
                                                value={qtdDisparos}
                                                onChange={(e) => setQtdDisparos(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                        {/* Linha 5: GJ Intermitente Az | GJ Intermitente Elv */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">GJ Intermitente Az</label>
                                            <input
                                                type="text"
                                                value={gjIntermAz}
                                                onChange={(e) => setGjIntermAz(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">GJ Intermitente Elv</label>
                                            <input
                                                type="text"
                                                value={gjIntermElv}
                                                onChange={(e) => setGjIntermElv(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                        {/* Linha 6: GJ Rajada Az | GJ Rajada Elv */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">GJ Rajada Az</label>
                                            <input
                                                type="text"
                                                value={gjRajadaAz}
                                                onChange={(e) => setGjRajadaAz(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">GJ Rajada Elv</label>
                                            <input
                                                type="text"
                                                value={gjRajadaElv}
                                                onChange={(e) => setGjRajadaElv(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Seção de Tipo de Alvo */}
                                <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200 mb-4 sm:mb-8">
                                    <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                         Configuração do Alvo
                                    </h2>
                                    
                                    <div className="mb-6">
                                        <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                            Tipo de Alvo
                                        </label>
                                        <select
                                            value={targetType}
                                            onChange={(e) => {
                                                setTargetType(e.target.value);
                                                // Reset calibração ao mudar tipo
                                                setCalibrationMode(false);
                                                setIsCalibrated(false);
                                                setCalibrationPoints({
                                                    center: null,
                                                    top: null,
                                                    bottom: null,
                                                    left: null,
                                                    right: null
                                                });
                                            }}
                                            className="w-full p-3 border-2 border-gray-300 rounded-lg text-lg"
                                            style={{color: '#262626', fontWeight: '600'}}
                                        >
                                            <option value="otan_230">OTAN 2,3m x 2,3m (230cm x 230cm)</option>
                                            <option value="otan_side">OTAN Side 4,6m x 2,3m (460cm x 230cm)</option>
                                            <option value="a1_vert">Folha A1 - Vertical (59,4cm x 84,1cm)</option>
                                            <option value="a1_horiz">Folha A1 - Horizontal (84,1cm x 59,4cm)</option>
                                            <option value="custom">Customizado</option>
                                        </select>
                                    </div>

                                    {targetType === 'custom' && (
                                        <div className="grid grid-cols-2 gap-4 mb-6">
                                            <div>
                                                <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                    Largura (cm)
                                                </label>
                                                <input
                                                    type="number"
                                                    value={customWidth}
                                                    onChange={(e) => setCustomWidth(parseFloat(e.target.value) || 230)}
                                                    className="w-full p-3 border-2 border-gray-300 rounded-lg"
                                                    step="0.1"
                                                    min="10"
                                                />
                                            </div>
                                            <div>
                                                <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                    Altura (cm)
                                                </label>
                                                <input
                                                    type="number"
                                                    value={customHeight}
                                                    onChange={(e) => setCustomHeight(parseFloat(e.target.value) || 230)}
                                                    className="w-full p-3 border-2 border-gray-300 rounded-lg"
                                                    step="0.1"
                                                    min="10"
                                                />
                                            </div>
                                        </div>
                                    )}

                                    <div className="bg-blue-50 p-4 rounded-lg border border-blue-200">
                                        <p className="text-sm text-blue-900">
                                            <strong>Alvo selecionado:</strong> {targetDims.width.toFixed(1)}cm (largura) x {targetDims.height.toFixed(1)}cm (altura)
                                        </p>
                                        <p className="text-xs text-blue-700 mt-2">
                                            Limites: X = ±{halfWidth.toFixed(1)}cm | Y = ±{halfHeight.toFixed(1)}cm
                                        </p>
                                    </div>
                                </div>

                                {/* Upload e Calibração */}
                                <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200 mb-4 sm:mb-8">
                                    <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                         Registro por Foto do Alvo
                                    </h2>
                                    
                                    <div className="mb-6">
                                        <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                            Upload da foto do alvo
                                        </label>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={handleImageUpload}
                                            className="w-full p-3 border-2 border-gray-300 rounded-lg"
                                        />
                                    </div>

                                    {uploadedImage && (
                                        <div>
                                            {calibrationMode && (
                                                <div className="mb-3 p-3 bg-gray-50 border-2 border-gray-300 rounded-lg">
                                                    <h3 className="font-bold text-gray-800 mb-1 text-sm sm:text-base">
                                                         Calibração - Passo {calibrationStep + 1} de 5
                                                    </h3>
                                                    <p className="text-gray-900 text-xs sm:text-sm">
                                                        Clique no ponto: <strong>{calibrationSteps[calibrationStep].label}</strong>
                                                    </p>
                                                </div>
                                            )}

                                            {isCalibrated && clickMode && (
                                                <div className="mb-3 p-3 bg-gray-50 border-2 border-gray-300 rounded-lg">
                                                    <h3 className="font-bold text-gray-800 mb-1 text-sm sm:text-base">
                                                         Calibração Concluída!
                                                    </h3>
                                                    {deleteMode ? (
                                                        <p className="text-red-400 font-bold text-sm sm:text-lg mb-2">
                                                             MODO APAGAR - Clique no disparo
                                                        </p>
                                                    ) : (
                                                        <p className="text-gray-800 mb-2 text-xs sm:text-sm">
                                                            <strong>Clique:</strong> Marcar impacto<br/>
                                                            <strong>Clique direito (PC):</strong> Apagar impacto
                                                        </p>
                                                    )}
                                                    <div className="flex gap-2 mt-2 flex-wrap">
                                                        <button
                                                            onClick={() => setClickMode(!clickMode)}
                                                            className="px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg font-semibold text-white text-xs sm:text-sm"
                                                            style={{background: clickMode ? '#f39c12' : '#262626'}}
                                                        >
                                                            {clickMode ? ' Pausar' : ' Retomar'}
                                                        </button>
                                                        <button
                                                            onClick={() => setDeleteMode(!deleteMode)}
                                                            className={`px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg font-semibold text-white text-xs sm:text-sm ${deleteMode ? 'bg-gray-50' : 'bg-zinc-600'}`}
                                                        >
                                                            {deleteMode ? ' Cancelar' : ' Apagar'}
                                                        </button>
                                                        <button
                                                            onClick={resetCalibration}
                                                            className="px-3 py-1.5 sm:px-4 sm:py-2 bg-zinc-600 hover:bg-zinc-500 text-white rounded-lg font-semibold text-xs sm:text-sm"
                                                        >
                                                             Recalibrar
                                                        </button>
                                                    </div>
                                                </div>
                                            )}

                                            <div className="flex justify-center">
                                                <canvas
                                                    ref={imageCanvasRef}
                                                    onClick={handleImageClick}
                                                    onContextMenu={handleImageRightClick}
                                                    className="border-4 rounded-lg shadow-lg max-w-full"
                                                    style={{
                                                        borderColor: '#262626',
                                                        cursor: deleteMode ? 'not-allowed' : 'crosshair'
                                                    }}
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>

                                <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-8">
                                    {/* Entrada Manual */}
                                    <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200">
                                        <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                            Entrada Manual
                                        </h2>
                                        
                                        <div className="mb-6">
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                Distância (metros)
                                            </label>
                                            <input
                                                type="number"
                                                value={distance}
                                                onChange={(e) => setDistance(parseFloat(e.target.value) || 0)}
                                                className="w-full p-3 border-2 border-gray-300 rounded-lg text-lg"
                                                step="1"
                                                min="1"
                                            />
                                        </div>

                                        <div className="mb-6">
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                Adicionar disparo (±{halfWidth.toFixed(1)}cm x ±{halfHeight.toFixed(1)}cm)
                                            </label>
                                            <div className="grid grid-cols-2 gap-3 mb-3">
                                                <input
                                                    type="number"
                                                    placeholder="X"
                                                    value={currentX}
                                                    onChange={(e) => setCurrentX(e.target.value)}
                                                    onKeyPress={handleKeyPress}
                                                    className="p-3 border-2 border-gray-300 rounded-lg"
                                                    step="0.1"
                                                />
                                                <input
                                                    type="number"
                                                    placeholder="Y"
                                                    value={currentY}
                                                    onChange={(e) => setCurrentY(e.target.value)}
                                                    onKeyPress={handleKeyPress}
                                                    className="p-3 border-2 border-gray-300 rounded-lg"
                                                    step="0.1"
                                                />
                                            </div>
                                            <button 
                                                onClick={addShot}
                                                className="w-full text-white py-3 rounded-lg font-semibold"
                                                style={{background: '#262626'}}
                                            >
                                                + Adicionar
                                            </button>
                                        </div>

                                        {shots.length > 0 && (
                                            <div>
                                                <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                    Disparos ({shots.length})
                                                </label>
                                                <div className="max-h-80 overflow-y-auto bg-white rounded-lg border-2 border-gray-300">
                                                    <table className="w-full text-sm">
                                                        <thead className="bg-gray-100 sticky top-0">
                                                            <tr>
                                                                <th className="px-3 py-2">#</th>
                                                                <th className="px-3 py-2">X(cm)</th>
                                                                <th className="px-3 py-2">Y(cm)</th>
                                                                <th className="px-3 py-2">X(mils)</th>
                                                                <th className="px-3 py-2">Y(mils)</th>
                                                                <th className="px-3 py-2"></th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {shots.map((shot, index) => {
                                                                const xMils = Math.atan((shot.x / 100) / distance) * 1000;
                                                                const yMils = Math.atan((shot.y / 100) / distance) * 1000;
                                                                return (
                                                                    <tr key={index} className="border-b hover:bg-white">
                                                                        <td className="px-3 py-2 text-center">{index + 1}</td>
                                                                        <td className="px-3 py-2 text-center">{shot.x.toFixed(1)}</td>
                                                                        <td className="px-3 py-2 text-center">{shot.y.toFixed(1)}</td>
                                                                        <td className="px-3 py-2 text-center font-medium" style={{color: '#262626'}}>{xMils.toFixed(2)}</td>
                                                                        <td className="px-3 py-2 text-center font-medium" style={{color: '#262626'}}>{yMils.toFixed(2)}</td>
                                                                        <td className="px-3 py-2 text-center">
                                                                            <button 
                                                                                onClick={() => removeShot(index)}
                                                                                className="bg-zinc-600 hover:bg-zinc-500 text-white px-2 py-1 rounded text-xs font-bold"
                                                                            >
                                                                                ×
                                                                            </button>
                                                                        </td>
                                                                    </tr>
                                                                );
                                                            })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                                <button 
                                                    onClick={clearAll}
                                                    className="w-full mt-4 bg-white0 text-white py-3 rounded-lg font-semibold"
                                                >
                                                    Limpar
                                                </button>
                                            </div>
                                        )}
                                    </div>

                                    {/* Resultados */}
                                    <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200">
                                        <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                            Resultados
                                        </h2>
                                        
                                        {results ? (
                                            <div className="space-y-4">
                                                <div className="bg-white p-5 rounded-xl shadow-sm" style={{borderLeft: '4px solid #262626'}}>
                                                    <h3 className="text-lg font-semibold mb-3">📍 Ponto Médio</h3>
                                                    <div className="space-y-2">
                                                        <div className="flex justify-between py-2 border-b">
                                                            <span className="font-semibold">X:</span>
                                                            <span className="font-bold">{results.meanX.toFixed(2)} cm</span>
                                                        </div>
                                                        <div className="flex justify-between py-2">
                                                            <span className="font-semibold">Y:</span>
                                                            <span className="font-bold">{results.meanY.toFixed(2)} cm</span>
                                                        </div>
                                                    </div>
                                                </div>

                                                <div className="bg-white p-5 rounded-xl shadow-sm" style={{borderLeft: '4px solid #262626'}}>
                                                    <h3 className="text-lg font-semibold mb-3"> Em Mils</h3>
                                                    <div className="space-y-2">
                                                        <div className="flex justify-between py-2 border-b">
                                                            <span className="font-semibold">Horizontal:</span>
                                                            <span className="font-bold">{results.meanXMils.toFixed(2)} mils</span>
                                                        </div>
                                                        <div className="flex justify-between py-2">
                                                            <span className="font-semibold">Vertical:</span>
                                                            <span className="font-bold">{results.meanYMils.toFixed(2)} mils</span>
                                                        </div>
                                                    </div>
                                                </div>

                                                <div className="bg-white p-5 rounded-xl shadow-sm" style={{borderLeft: '4px solid #262626'}}>
                                                    <h3 className="text-lg font-semibold mb-3">📊 Desvio Padrão</h3>
                                                    <div className="space-y-2">
                                                        <div className="flex justify-between py-2 border-b">
                                                            <span className="font-semibold">Horizontal:</span>
                                                            <span className="font-bold">{results.stdDevXMils.toFixed(2)} mils</span>
                                                        </div>
                                                        <div className="flex justify-between py-2 border-b">
                                                            <span className="font-semibold">Vertical:</span>
                                                            <span className="font-bold">{results.stdDevYMils.toFixed(2)} mils</span>
                                                        </div>
                                                        <div className="flex justify-between py-2">
                                                            <span className="font-semibold">Radial:</span>
                                                            <span className="font-bold">{results.stdDevRadialMils.toFixed(2)} mils</span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="text-center py-16 text-gray-800">
                                                <p className="text-xl">Adicione disparos</p>
                                            </div>
                                        )}
                                    </div>
                                </div>

                                {/* Visualização */}
                                {shots.length > 0 && (
                                    <div className="mt-4 sm:mt-8">
                                        <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                             Visualização do Alvo
                                        </h2>
                                        
                                        {/* Alvo Principal - Grande */}
                                        <div className="mb-6">
                                            <p className="text-gray-600 mb-3 text-sm font-semibold">Alvo Real - {distance}m</p>
                                            <canvas 
                                                ref={canvasRef} 
                                                width={450} 
                                                height={450} 
                                                className="bg-white rounded-lg shadow-lg mx-auto"
                                                style={{maxWidth: '450px', width: '100%', height: 'auto'}}
                                            />
                                        </div>

                                        {/* Simulações - Pequenas */}
                                        <div className="mt-6">
                                            <p className="text-gray-600 mb-3 text-sm font-semibold">
                                                Simulações em Diferentes Distâncias (Alvo OTAN 2,3m x 2,3m)
                                            </p>
                                            <div className="grid grid-cols-2 lg:grid-cols-4 gap-3">
                                                {[100, 500, 1000, 1500].map(d => (
                                                    <DistanceSimulation 
                                                        key={d}
                                                        distance={d}
                                                        shots={shots}
                                                        results={results}
                                                        currentDistance={distance}
                                                    />
                                                ))}
                                            </div>
                                        </div>

                                        <div className="mt-6 sm:mt-8">
                                            <button
                                                onClick={generatePDF}
                                                className="w-full py-3 sm:py-5 text-white rounded-xl font-bold text-base sm:text-xl transition-all transform hover:-translate-y-1 hover:shadow-2xl flex items-center justify-center gap-2 sm:gap-3"
                                                style={{background: 'linear-gradient(to right, #262626, #262626)'}}
                                            >
                                                <span className="text-xl sm:text-2xl"></span>
                                                <span>Gerar Relatório em PDF</span>
                                            </button>
                                            <p className="text-center text-gray-600 text-xs sm:text-sm mt-2 sm:mt-3">
                                                Relatório completo com dados balísticos e visualizações
                                            </p>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>