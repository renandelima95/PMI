<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#262626">
    <meta name="description" content="ARES - Calculadora de Dispersão e Ponto Médio de Impacto">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ARES PMI">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="./assets/icons/icon-192x192.png">
    <title>ARES - Cálculo de Dispersão e PMI</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com/3.4.17"></script>
    <style>
        * {
            font-family: Helvetica, Arial, sans-serif;
        }
        body {
            background-color: #262626;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const ARES_LOGO = "./assets/Logo_Ares_1.png";

        // Tipos de alvo pré-definidos
        const TARGET_TYPES = {
            'otan_230': { name: 'OTAN 2,3m x 2,3m', width: 230, height: 230 },
            'otan_side': { name: 'OTAN Side 4,6m x 2,3m', width: 460, height: 230 },
            'a1_vert': { name: 'Folha A1 (Vertical)', width: 59.4, height: 84.1 },
            'a1_horiz': { name: 'Folha A1 (Horizontal)', width: 84.1, height: 59.4 },
            'custom': { name: 'Customizado', width: 230, height: 230 }
        };

        // Componente de simulação - SEMPRE usa OTAN 2,3x2,3m
        function DistanceSimulation({ distance, shots, results, currentDistance }) {
            const canvasRef = useRef(null);

            // Calcular missedShots fora do useEffect para usar no JSX
            const simulatedShots = shots.map(shot => {
                const angleXRad = Math.atan((shot.x / 100) / currentDistance);
                const angleYRad = Math.atan((shot.y / 100) / currentDistance);
                const newX = Math.tan(angleXRad) * distance * 100;
                const newY = Math.tan(angleYRad) * distance * 100;
                return { x: newX, y: newY };
            });

            const missedShots = simulatedShots.filter(shot => 
                Math.abs(shot.x) > 115 || Math.abs(shot.y) > 115
            ).length;

            useEffect(() => {
                if (!canvasRef.current || !results) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;

                const scale = width / 230; // OTAN padrão

                ctx.fillStyle = '#d0d0d0';
                ctx.fillRect(0, 0, width, height);

                // Desenhar alvo NATO
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(centerX, 0, width/2, height/2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width/2, height/2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, centerY, width/2, height/2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(centerX, centerY, width/2, height/2);

                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, height);
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();

                simulatedShots.forEach(shot => {
                    const x = centerX + shot.x * scale;
                    const y = centerY - shot.y * scale;
                    const isInside = Math.abs(shot.x) <= 115 && Math.abs(shot.y) <= 115;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fillStyle = isInside ? '#e74c3c' : '#FF6B6B';
                    ctx.fill();
                    ctx.strokeStyle = isInside ? '#c0392b' : '#FF0000';
                    ctx.lineWidth = isInside ? 1.5 : 2;
                    ctx.stroke();
                    
                    if (!isInside) {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x - 6, y - 6);
                        ctx.lineTo(x + 6, y + 6);
                        ctx.moveTo(x + 6, y - 6);
                        ctx.lineTo(x - 6, y + 6);
                        ctx.stroke();
                    }
                });

                const meanAngleXRad = Math.atan((results.meanX / 100) / currentDistance);
                const meanAngleYRad = Math.atan((results.meanY / 100) / currentDistance);
                const simMeanX = Math.tan(meanAngleXRad) * distance * 100;
                const simMeanY = Math.tan(meanAngleYRad) * distance * 100;
                
                const meanPixelX = centerX + simMeanX * scale;
                const meanPixelY = centerY - simMeanY * scale;
                
                ctx.beginPath();
                ctx.arc(meanPixelX, meanPixelY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = '#3498db';
                ctx.fill();
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 2;
                ctx.stroke();

            }, [distance, shots, results, currentDistance, simulatedShots]);

            return (
                <div className="bg-white p-2 sm:p-4 rounded-xl border-2 border-gray-200">
                    <div className="text-center mb-1 sm:mb-2">
                        <span className="text-sm sm:text-lg font-bold" style={{color: '#262626'}}>{distance}m</span>
                    </div>
                    <canvas
                        ref={canvasRef}
                        width={280}
                        height={280}
                        className="bg-white rounded-lg shadow-md mx-auto"
                        style={{maxWidth: '100%', width: '100%', height: 'auto'}}
                    />
                    <div className="text-center mt-1 sm:mt-2">
                        <p className="text-xs text-gray-500 hidden sm:block">OTAN 2,3m x 2,3m</p>
                        <p className={`text-xs sm:text-sm font-semibold ${missedShots > 0 ? 'text-red-600' : 'text-green-600'}`}>
                            {missedShots > 0 ? `${missedShots} fora` : 'Todos dentro'}
                        </p>
                    </div>
                </div>
            );
        }

        // Componente principal
        function App() {
            const [distance, setDistance] = useState(100);
            const [shots, setShots] = useState([]);
            const [currentX, setCurrentX] = useState('');
            const [currentY, setCurrentY] = useState('');
            const canvasRef = useRef(null);
            
            // Tipo de alvo
            const [targetType, setTargetType] = useState('otan_230');
            const [customWidth, setCustomWidth] = useState(230);
            const [customHeight, setCustomHeight] = useState(230);
            
            const [uploadedImage, setUploadedImage] = useState(null);
            const [originalImageElement, setOriginalImageElement] = useState(null);
            const [calibrationMode, setCalibrationMode] = useState(false);
            const [calibrationStep, setCalibrationStep] = useState(0);
            const [calibrationPoints, setCalibrationPoints] = useState({
                center: null,
                top: null,
                bottom: null,
                left: null,
                right: null
            });
            const [isCalibrated, setIsCalibrated] = useState(false);
            const [clickMode, setClickMode] = useState(false);
            const [deleteMode, setDeleteMode] = useState(false);
            const imageCanvasRef = useRef(null);
            
            // Estados para Cenário de Teste
            const [descricao, setDescricao] = useState('');
            const [atirador, setAtirador] = useState('');
            const [sistema, setSistema] = useState(() => localStorage.getItem('cenario_sistema') || 'REMAX 3');
            const [sistemaOutro, setSistemaOutro] = useState('');
            const [sn, setSn] = useState('');
            const [armamento, setArmamento] = useState(() => localStorage.getItem('cenario_armamento') || '30mm');
            const [armamentoOutro, setArmamentoOutro] = useState('');
            const [condicoesTeste, setCondicoesTeste] = useState(() => localStorage.getItem('cenario_condicoes') || 'Estático');
            const [cenarioMovimento, setCenarioMovimento] = useState('');
            const [tipoMunicao, setTipoMunicao] = useState(() => localStorage.getItem('cenario_municao') || 'HEI');
            const [municaoOutro, setMunicaoOutro] = useState('');
            const [tipoDisparo, setTipoDisparo] = useState(() => localStorage.getItem('cenario_disparo') || 'Intermitente');
            const [qtdDisparos, setQtdDisparos] = useState('');
            const [modo, setModo] = useState('');
            const [gjIntermAz, setGjIntermAz] = useState('');
            const [gjIntermElv, setGjIntermElv] = useState('');
            const [gjRajadaAz, setGjRajadaAz] = useState('');
            const [gjRajadaElv, setGjRajadaElv] = useState('');
            
            // Carregar configurações do JSON
            const [config, setConfig] = useState({
                sistema: ["REMAX 3", "REMAX 4", "CORCED", "UT30BR", "UT30BR2", "Outro"],
                armamento: ["30mm", "12.7mm", "7.62mm", "Outro"],
                condicoes_teste: ["Estático", "Movimento"],
                tipo_disparo: ["Intermitente", "Rajada"],
                municao: {
                    "30mm": ["HEI", "HET", "APFDS"],
                    "12.7mm": ["Comum", "Traçante"],
                    "7.62mm": ["Comum", "Traçante"]
                }
            });
            
            useEffect(() => {
                fetch('./assets/config.json', { cache: 'no-store' })
                    .then(res => res.json())
                    .then(data => setConfig(data))
                    .catch(err => {
                        console.warn('Não foi possível carregar config.json, usando valores padrão:', err);
                    });
            }, []);
            
            // Salvar seleções no localStorage
            useEffect(() => {
                localStorage.setItem('cenario_sistema', sistema);
            }, [sistema]);
            
            useEffect(() => {
                localStorage.setItem('cenario_armamento', armamento);
            }, [armamento]);
            
            useEffect(() => {
                localStorage.setItem('cenario_condicoes', condicoesTeste);
            }, [condicoesTeste]);
            
            useEffect(() => {
                localStorage.setItem('cenario_municao', tipoMunicao);
            }, [tipoMunicao]);
            
            useEffect(() => {
                localStorage.setItem('cenario_disparo', tipoDisparo);
            }, [tipoDisparo]);

            // Obter dimensões do alvo atual - MEMOIZADO para evitar loops
            const targetDims = useMemo(() => {
                if (targetType === 'custom') {
                    return { width: customWidth, height: customHeight };
                }
                return TARGET_TYPES[targetType];
            }, [targetType, customWidth, customHeight]);

            const halfWidth = targetDims.width / 2;
            const halfHeight = targetDims.height / 2;

            const calibrationSteps = [
                { key: 'center', label: 'Centro do alvo (0, 0)' },
                { key: 'top', label: `Topo do alvo (Y = +${halfHeight.toFixed(1)} cm)` },
                { key: 'bottom', label: `Base do alvo (Y = -${halfHeight.toFixed(1)} cm)` },
                { key: 'left', label: `Esquerda do alvo (X = -${halfWidth.toFixed(1)} cm)` },
                { key: 'right', label: `Direita do alvo (X = +${halfWidth.toFixed(1)} cm)` }
            ];

            // Calcular matriz de homografia (perspectiva)
            const calculateHomography = () => {
                if (!isCalibrated) return null;
                
                const { topLeft, topRight, bottomRight, bottomLeft } = calibrationPoints;
                
                // Pontos na imagem (origem)
                const srcPoints = [
                    [topLeft.x, topLeft.y],
                    [topRight.x, topRight.y],
                    [bottomRight.x, bottomRight.y],
                    [bottomLeft.x, bottomLeft.y]
                ];
                
                // Pontos no alvo real (destino) - em centímetros
                const dstPoints = [
                    [-halfWidth, halfHeight],   // top-left
                    [halfWidth, halfHeight],    // top-right
                    [halfWidth, -halfHeight],   // bottom-right
                    [-halfWidth, -halfHeight]   // bottom-left
                ];
                
                // Resolver sistema linear para encontrar matriz de homografia
                // Simplified Direct Linear Transformation (DLT)
                const A = [];
                for (let i = 0; i < 4; i++) {
                    const [x, y] = srcPoints[i];
                    const [X, Y] = dstPoints[i];
                    A.push([-x, -y, -1, 0, 0, 0, x*X, y*X, X]);
                    A.push([0, 0, 0, -x, -y, -1, x*Y, y*Y, Y]);
                }
                
                // Resolver Ah = 0 usando SVD simplificado
                // Para simplificar, vou usar método direto
                return { srcPoints, dstPoints };
            };

            const loadImageAsDataURL = (src) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve(canvas.toDataURL('image/png'));
                    };
                    img.onerror = () => resolve(null);
                    img.src = src;
                });
            };

            const generatePDF = async () => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const results = calculateResults();

                if (!results) {
                    alert('Adicione disparos antes de gerar o PDF');
                    return;
                }

                // Load logos for PDF
                const logoDataURL = await loadImageAsDataURL(ARES_LOGO);
                // Load system-specific logo (e.g. UT30BR.png)
                const sistemaName = sistema === 'Outro' ? null : sistema;
                const systemLogoURL = sistemaName ? await loadImageAsDataURL(`./assets/${sistemaName}.png`) : null;

                // Logo dimensions
                const logoW = 39;
                const logoH = 7;

                // Helper: draw standard page header with ARES logo centered-left and system logo on right
                const drawHeader = (title) => {
                    doc.setFillColor(229, 230, 231);
                    doc.rect(0, 0, 210, 25, 'F');
                    if (logoDataURL) {
                        // Center the ARES logo: place it so that the title area is truly centered
                        const aresLogoX = 10;
                        doc.addImage(logoDataURL, 'PNG', aresLogoX, 5, logoW, logoH);
                    }
                    if (systemLogoURL) {
                        // System logo on the right side, same size as ARES logo
                        const sysLogoX = 210 - 10 - logoW;
                        doc.addImage(systemLogoURL, 'PNG', sysLogoX, 5, logoW, logoH);
                    }
                    doc.setTextColor(38, 38, 38);
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.text(title, 105, 11, { align: 'center' });
                    const date = new Date().toLocaleString('pt-BR');
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'normal');
                    doc.text(`Gerado em: ${date}`, 105, 18, { align: 'center' });
                };

                // Preparar valores
                const descricaoText = descricao || '-';
                const atiradorText = atirador || '-';
                const sistemaText = sistema === 'Outro' ? (sistemaOutro || '-') : (sistema || '-');
                const snText = sn || '-';
                const armamentoText = armamento === 'Outro' ? (armamentoOutro || '-') : (armamento || '-');
                const municaoText = armamento === 'Outro' ? (municaoOutro || 'Outro') : (tipoMunicao || '-');
                const condicoesText = condicoesTeste || '-';
                const movimentoText = (condicoesTeste === 'Movimento' && cenarioMovimento) ? cenarioMovimento : '';
                const modoText = modo || '-';
                const disparoText = tipoDisparo || '-';
                const qtdText = qtdDisparos || '-';
                const gjIntermAzText = gjIntermAz || '-';
                const gjIntermElvText = gjIntermElv || '-';
                const gjRajadaAzText = gjRajadaAz || '-';
                const gjRajadaElvText = gjRajadaElv || '-';

                // =====================================================
                // PAGE 1: Cenário de Teste + Alvo + Resultados + Simulações
                // =====================================================
                drawHeader('Cálculo de Dispersão e PMI');
                let y = 30;

                // --- Cenário de Teste (styled table) ---
                doc.setFontSize(11);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(38, 38, 38);
                doc.text('Cenário de Teste', 15, y);
                y += 2;

                const scenarioData = [
                    ['Descrição', descricaoText, 'Atirador', atiradorText],
                    ['Sistema', sistemaText, 'S/N', snText],
                    ['Armamento', armamentoText, 'Munição', municaoText],
                    ['Condições', condicoesText + (movimentoText ? ` - ${movimentoText}` : ''), 'Modo', modoText],
                    ['Tipo Disparo', disparoText, 'Qtd Disparos', qtdText],
                ];

                const cellH = 6;
                const labelW = 30;
                const valueW = 40;
                const colPairW = labelW + valueW;
                const tableX = 15;
                const fullTableW = 180;

                // Helper to draw a 2-column paired table
                const drawPairedTable = (data, startY) => {
                    data.forEach((row, ri) => {
                        const rowY = startY + ri * cellH;
                        if (ri % 2 === 0) {
                            doc.setFillColor(245, 245, 245);
                            doc.rect(tableX, rowY, fullTableW, cellH, 'F');
                        }
                        doc.setFontSize(7);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(80, 80, 80);
                        doc.text(row[0], tableX + 2, rowY + 4);
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(0, 0, 0);
                        // Truncate long values to fit
                        const val1 = doc.splitTextToSize(row[1], valueW + 15);
                        doc.text(val1[0], tableX + labelW + 2, rowY + 4);
                        const col2Start = tableX + fullTableW / 2;
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(80, 80, 80);
                        doc.text(row[2], col2Start + 2, rowY + 4);
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(0, 0, 0);
                        doc.text(row[3], col2Start + labelW + 2, rowY + 4);
                    });
                    const tH = data.length * cellH;
                    doc.setDrawColor(200, 200, 200);
                    doc.setLineWidth(0.3);
                    doc.rect(tableX, startY, fullTableW, tH);
                    return tH;
                };

                const scenarioH = drawPairedTable(scenarioData, y);
                y += scenarioH + 4;

                // --- Parâmetros GJ (half-width table, before Alvo) ---
                doc.setFontSize(11);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(38, 38, 38);
                doc.text('Parâmetros GJ', 15, y);
                y += 2;

                const gjHalfW = 90; // half page width
                const gjLabelW = 28;
                const gjData = [
                    ['GJ Interm. Az', gjIntermAzText, 'GJ Interm. Elv', gjIntermElvText],
                    ['GJ Rajada Az', gjRajadaAzText, 'GJ Rajada Elv', gjRajadaElvText],
                ];
                // Draw half-width paired table for GJ
                gjData.forEach((row, ri) => {
                    const rowY = y + ri * cellH;
                    if (ri % 2 === 0) {
                        doc.setFillColor(245, 245, 245);
                        doc.rect(tableX, rowY, gjHalfW, cellH, 'F');
                    }
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(80, 80, 80);
                    doc.text(row[0], tableX + 2, rowY + 4);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(0, 0, 0);
                    doc.text(row[1], tableX + gjLabelW + 2, rowY + 4);
                    const col2Start = tableX + gjHalfW / 2;
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(80, 80, 80);
                    doc.text(row[2], col2Start + 2, rowY + 4);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(0, 0, 0);
                    doc.text(row[3], col2Start + gjLabelW + 2, rowY + 4);
                });
                const gjH = gjData.length * cellH;
                doc.setDrawColor(200, 200, 200);
                doc.setLineWidth(0.3);
                doc.rect(tableX, y, gjHalfW, gjH);
                y += gjH + 4;

                // --- Parâmetros do Alvo ---
                doc.setFontSize(11);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(38, 38, 38);
                doc.text('Parâmetros do Alvo', 15, y);
                y += 2;

                const targetData = [
                    ['Tipo de Alvo', TARGET_TYPES[targetType]?.name || 'Customizado', 'Distância', `${distance} m`],
                    ['Dimensões', `${targetDims.width.toFixed(1)} x ${targetDims.height.toFixed(1)} cm`, 'Disparos', `${shots.length}`],
                ];
                const targetH = drawPairedTable(targetData, y);
                y += targetH + 4;

                // --- Alvo principal + Resultados side by side ---
                if (canvasRef.current && shots.length > 0) {
                    const imgData = canvasRef.current.toDataURL('image/png');
                    const targetImgSize = 80;
                    const resultsColX = tableX + targetImgSize + 5; // results start after target image
                    const resultsColW = fullTableW - targetImgSize - 5;

                    // Check if target image fits on current page
                    if (y + targetImgSize + 60 > 280) {
                        doc.addPage();
                        drawHeader('Cálculo de Dispersão e PMI');
                        y = 30;
                    }

                    // Draw target image on the left
                    doc.addImage(imgData, 'PNG', tableX, y, targetImgSize, targetImgSize);

                    // --- Resultados on the right side ---
                    let ry = y;
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(38, 38, 38);
                    doc.text('Resultados', resultsColX, ry);
                    ry += 4;

                    // PMI section
                    doc.setFillColor(245, 245, 245);
                    doc.rect(resultsColX, ry, resultsColW, 16, 'F');
                    doc.setDrawColor(200, 200, 200);
                    doc.rect(resultsColX, ry, resultsColW, 16);

                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(38, 38, 38);
                    doc.text('Ponto Médio de Impacto (PMI)', resultsColX + 3, ry + 5);
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`X: ${results.meanX.toFixed(2)} cm  |  ${results.meanXMils.toFixed(2)} mils`, resultsColX + 3, ry + 10);
                    doc.text(`Y: ${results.meanY.toFixed(2)} cm  |  ${results.meanYMils.toFixed(2)} mils`, resultsColX + 3, ry + 14);
                    ry += 18;

                    // Dispersão section
                    doc.setFillColor(245, 245, 245);
                    doc.rect(resultsColX, ry, resultsColW, 20, 'F');
                    doc.setDrawColor(200, 200, 200);
                    doc.rect(resultsColX, ry, resultsColW, 20);

                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(38, 38, 38);
                    doc.text('Desvio Padrão (Dispersão)', resultsColX + 3, ry + 5);
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`Horizontal: ${results.stdDevXMils.toFixed(2)} mils`, resultsColX + 3, ry + 10);
                    doc.text(`Vertical: ${results.stdDevYMils.toFixed(2)} mils`, resultsColX + 3, ry + 14);
                    doc.text(`Radial: ${results.stdDevRadialMils.toFixed(2)} mils`, resultsColX + 3, ry + 18);
                    ry += 22;

                    // Shot status
                    const shotsInside = shots.filter(shot => {
                        const halfW = targetDims.width / 2;
                        const halfH = targetDims.height / 2;
                        return Math.abs(shot.x) <= halfW && Math.abs(shot.y) <= halfH;
                    }).length;
                    const shotsOutside = shots.length - shotsInside;

                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    if (shotsOutside > 0) {
                        doc.setTextColor(220, 38, 38);
                        doc.text(`${shotsOutside} disparo${shotsOutside > 1 ? 's' : ''} fora do alvo`, resultsColX + 3, ry);
                    } else {
                        doc.setTextColor(34, 139, 34);
                        doc.text('Todos os disparos dentro do alvo', resultsColX + 3, ry);
                    }

                    // Move y past the target image (whichever is taller)
                    y += targetImgSize + 5;

                    // --- Simulações (on first page) ---
                    if (y + 55 > 280) {
                        doc.addPage();
                        drawHeader('Simulações');
                        y = 30;
                    }
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(38, 38, 38);
                    doc.text('Simulações (OTAN 2,3m x 2,3m)', 105, y, { align: 'center' });
                    y += 3;

                    const distances = [100, 500, 1000, 1500];
                    const simSize = 40;
                    const simGap = (180 - 4 * simSize) / 3;
                    const simStartX = 15;

                    distances.forEach((dist, index) => {
                        const posX = simStartX + index * (simSize + simGap);

                        const simCanvas = document.createElement('canvas');
                        simCanvas.width = 300;
                        simCanvas.height = 300;
                        const ctx = simCanvas.getContext('2d');

                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, 300, 300);

                        const scale = 300 / 230;
                        const centerX = 150;
                        const centerY = 150;
                        const tw = 230 * scale;
                        const th = 230 * scale;
                        const left = centerX - tw / 2;
                        const top = centerY - th / 2;

                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(centerX, top, tw/2, th/2);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(left, top, tw/2, th/2);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(left, centerY, tw/2, th/2);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(centerX, centerY, tw/2, th/2);

                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(left, top, tw, th);

                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(centerX, top);
                        ctx.lineTo(centerX, top + th);
                        ctx.moveTo(left, centerY);
                        ctx.lineTo(left + tw, centerY);
                        ctx.stroke();

                        let shotsInsideSim = 0;
                        shots.forEach(shot => {
                            const angleXRad = Math.atan((shot.x / 100) / distance);
                            const angleYRad = Math.atan((shot.y / 100) / distance);
                            const newX = Math.tan(angleXRad) * dist * 100;
                            const newY = Math.tan(angleYRad) * dist * 100;

                            const x = centerX + newX * scale;
                            const yy = centerY - newY * scale;
                            const isInside = Math.abs(newX) <= 115 && Math.abs(newY) <= 115;
                            if (isInside) shotsInsideSim++;

                            ctx.beginPath();
                            ctx.arc(x, yy, 6, 0, 2 * Math.PI);
                            ctx.fillStyle = isInside ? '#e74c3c' : '#FF6B6B';
                            ctx.fill();
                            ctx.strokeStyle = isInside ? '#c0392b' : '#FF0000';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        });

                        const simData = simCanvas.toDataURL('image/png');
                        doc.addImage(simData, 'PNG', posX, y, simSize, simSize);

                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(38, 38, 38);
                        doc.text(`${dist}m`, posX + simSize / 2, y + simSize + 4, { align: 'center' });

                        const shotsOutsideSim = shots.length - shotsInsideSim;
                        doc.setFontSize(7);
                        doc.setFont('helvetica', 'normal');
                        if (shotsOutsideSim > 0) {
                            doc.setTextColor(220, 38, 38);
                            doc.text(`${shotsOutsideSim} fora`, posX + simSize / 2, y + simSize + 8, { align: 'center' });
                        } else {
                            doc.setTextColor(34, 139, 34);
                            doc.text('Todos dentro', posX + simSize / 2, y + simSize + 8, { align: 'center' });
                        }
                    });
                }

                // =====================================================
                // PAGE 2: Tabela de Disparos (Excel-friendly)
                // =====================================================
                doc.addPage();
                drawHeader('Tabela de Disparos');
                let yPos = 32;

                // Column definitions for proper grid table (full width: 15 to 195 = 180)
                const colDefs = [
                    { label: '#', x: 15, w: 15 },
                    { label: 'X (cm)', x: 30, w: 33 },
                    { label: 'Y (cm)', x: 63, w: 33 },
                    { label: 'X (mils)', x: 96, w: 33 },
                    { label: 'Y (mils)', x: 129, w: 33 },
                    { label: 'Distância (m)', x: 162, w: 33 },
                ];
                const totalTableW = 180;
                const rowH = 7;

                const drawTableHeader = (yy) => {
                    doc.setFillColor(38, 38, 38);
                    doc.rect(colDefs[0].x, yy - 5, totalTableW, rowH, 'F');
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(255, 255, 255);
                    colDefs.forEach(col => {
                        doc.text(col.label, col.x + col.w / 2, yy, { align: 'center' });
                    });
                    // Column grid lines
                    doc.setDrawColor(200, 200, 200);
                    doc.setLineWidth(0.2);
                    return yy + rowH;
                };

                yPos = drawTableHeader(yPos);

                doc.setFontSize(8);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(0, 0, 0);

                shots.forEach((shot, index) => {
                    const xMils = Math.atan((shot.x / 100) / distance) * 1000;
                    const yMils = Math.atan((shot.y / 100) / distance) * 1000;

                    if (yPos > 272) {
                        doc.addPage();
                        drawHeader('Tabela de Disparos');
                        yPos = 32;
                        yPos = drawTableHeader(yPos);
                        doc.setFontSize(8);
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(0, 0, 0);
                    }

                    // Alternate row background
                    if (index % 2 === 0) {
                        doc.setFillColor(248, 248, 248);
                        doc.rect(colDefs[0].x, yPos - 5, totalTableW, rowH, 'F');
                    }

                    // Row border
                    doc.setDrawColor(220, 220, 220);
                    doc.setLineWidth(0.1);
                    doc.rect(colDefs[0].x, yPos - 5, totalTableW, rowH);

                    // Cell borders
                    colDefs.forEach(col => {
                        doc.rect(col.x, yPos - 5, col.w, rowH);
                    });

                    doc.setTextColor(0, 0, 0);
                    const rowData = [
                        `${index + 1}`,
                        shot.x.toFixed(2),
                        shot.y.toFixed(2),
                        xMils.toFixed(4),
                        yMils.toFixed(4),
                        `${distance}`,
                    ];
                    colDefs.forEach((col, ci) => {
                        doc.text(rowData[ci], col.x + col.w / 2, yPos, { align: 'center' });
                    });

                    yPos += rowH;
                });

                // Summary row
                if (yPos > 265) {
                    doc.addPage();
                    drawHeader('Tabela de Disparos');
                    yPos = 32;
                    yPos = drawTableHeader(yPos);
                }
                doc.setFillColor(229, 230, 231);
                doc.rect(colDefs[0].x, yPos - 5, totalTableW, rowH * 2, 'F');
                doc.setDrawColor(200, 200, 200);
                doc.rect(colDefs[0].x, yPos - 5, totalTableW, rowH * 2);

                doc.setFontSize(7);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(38, 38, 38);
                doc.text('PMI', colDefs[0].x + 3, yPos);
                doc.setFont('helvetica', 'normal');
                doc.text(`X: ${results.meanX.toFixed(2)} cm  (${results.meanXMils.toFixed(2)} mils)`, colDefs[1].x + 3, yPos);
                doc.text(`Y: ${results.meanY.toFixed(2)} cm  (${results.meanYMils.toFixed(2)} mils)`, colDefs[3].x + 3, yPos);
                yPos += rowH;
                doc.setFont('helvetica', 'bold');
                doc.text('Desvio', colDefs[0].x + 3, yPos);
                doc.setFont('helvetica', 'normal');
                doc.text(`Horiz: ${results.stdDevXMils.toFixed(2)} mils  |  Vert: ${results.stdDevYMils.toFixed(2)} mils  |  Radial: ${results.stdDevRadialMils.toFixed(2)} mils`, colDefs[1].x + 3, yPos);

                // =====================================================
                // PAGE 3: Fotos do Alvo (original + com marcações)
                // =====================================================
                if (uploadedImage) {
                    doc.addPage();
                    drawHeader('Registro Fotográfico');
                    let yPhoto = 30;

                    // Helper to get image dimensions respecting orientation
                    const getOrientedImage = (dataURL) => {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.naturalWidth;
                                canvas.height = img.naturalHeight;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                resolve({
                                    data: canvas.toDataURL('image/png'),
                                    width: img.naturalWidth,
                                    height: img.naturalHeight
                                });
                            };
                            img.onerror = () => resolve({ data: dataURL, width: 1, height: 1 });
                            img.src = dataURL;
                        });
                    };

                    const oriented = await getOrientedImage(uploadedImage);
                    const aspectRatio = oriented.width / oriented.height;

                    // Calculate image dimensions to fit well on the page
                    const maxImgW = 170;
                    const maxImgH = 100;
                    let imgW, imgH;
                    if (aspectRatio > maxImgW / maxImgH) {
                        imgW = maxImgW;
                        imgH = maxImgW / aspectRatio;
                    } else {
                        imgH = maxImgH;
                        imgW = maxImgH * aspectRatio;
                    }
                    const imgX = (210 - imgW) / 2;

                    // Original photo
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(38, 38, 38);
                    doc.text('Foto Original', 105, yPhoto, { align: 'center' });
                    yPhoto += 3;
                    doc.addImage(oriented.data, 'PNG', imgX, yPhoto, imgW, imgH);
                    yPhoto += imgH + 8;

                    // Photo with markings
                    if (imageCanvasRef.current) {
                        doc.text('Foto com Marcações', 105, yPhoto, { align: 'center' });
                        yPhoto += 3;
                        const markedData = imageCanvasRef.current.toDataURL('image/png');
                        const markedOriented = await getOrientedImage(markedData);
                        const mAR = markedOriented.width / markedOriented.height;
                        let mW, mH;
                        if (mAR > maxImgW / maxImgH) {
                            mW = maxImgW;
                            mH = maxImgW / mAR;
                        } else {
                            mH = maxImgH;
                            mW = maxImgH * mAR;
                        }
                        const mX = (210 - mW) / 2;
                        doc.addImage(markedOriented.data, 'PNG', mX, yPhoto, mW, mH);
                    }
                }

                // =====================================================
                // Footer with page numbers on all pages
                // =====================================================
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFillColor(38, 38, 38);
                    doc.rect(0, 287, 210, 10, 'F');
                    doc.setTextColor(229, 230, 231);
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.text('ARES - Tecnologia Brasileira em Defesa', 105, 293, { align: 'center' });
                    doc.setFontSize(7);
                    doc.text(`${i} / ${pageCount}`, 200, 293, { align: 'right' });
                }

                const fileName = `ARES_Calculo_Dispersao_PMI_${Date.now()}.pdf`;
                const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;

                if (isStandalone && navigator.share && navigator.canShare) {
                    // Android PWA: use Web Share API to save/share the PDF
                    const pdfBlob = doc.output('blob');
                    const file = new File([pdfBlob], fileName, { type: 'application/pdf' });
                    if (navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share({ files: [file], title: fileName });
                        } catch (err) {
                            if (err.name !== 'AbortError') {
                                // Share failed for a reason other than user cancel, fallback to open
                                const url = URL.createObjectURL(pdfBlob);
                                window.open(url, '_blank');
                            }
                        }
                    } else {
                        // canShare says no for files, fallback to open in new tab
                        const pdfBlob2 = doc.output('blob');
                        const url = URL.createObjectURL(pdfBlob2);
                        window.open(url, '_blank');
                    }
                } else {
                    doc.save(fileName);
                }
            };

            const clearAll = () => {
                if (!window.confirm('Tem certeza que deseja limpar todos os dados?')) return;
                setShots([]);
                setCurrentX('');
                setCurrentY('');
                setDistance(100);
                setTargetType('otan_230');
                setCustomWidth(230);
                setCustomHeight(230);
                setUploadedImage(null);
                setOriginalImageElement(null);
                setCalibrationMode(false);
                setCalibrationStep(0);
                setCalibrationPoints({ center: null, top: null, bottom: null, left: null, right: null });
                setIsCalibrated(false);
                setClickMode(false);
                setDeleteMode(false);
                setDescricao('');
                setAtirador('');
                setSistemaOutro('');
                setSn('');
                setArmamentoOutro('');
                setCenarioMovimento('');
                setMunicaoOutro('');
                setQtdDisparos('');
                setModo('');
                setGjIntermAz('');
                setGjIntermElv('');
                setGjRajadaAz('');
                setGjRajadaElv('');
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    // Use createImageBitmap to handle EXIF orientation (fixes mobile rotation)
                    createImageBitmap(file).then((bitmap) => {
                        const canvas = document.createElement('canvas');
                        canvas.width = bitmap.width;
                        canvas.height = bitmap.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(bitmap, 0, 0);
                        const correctedDataURL = canvas.toDataURL('image/png');

                        const img = new Image();
                        img.onload = () => {
                            setUploadedImage(correctedDataURL);
                            setOriginalImageElement(img);
                            setCalibrationMode(true);
                            setCalibrationStep(0);
                            setCalibrationPoints({
                                center: null,
                                top: null,
                                bottom: null,
                                left: null,
                                right: null
                            });
                            setIsCalibrated(false);
                            setClickMode(false);
                        };
                        img.src = correctedDataURL;
                    }).catch(() => {
                        // Fallback for older browsers
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                setUploadedImage(event.target.result);
                                setOriginalImageElement(img);
                                setCalibrationMode(true);
                                setCalibrationStep(0);
                                setCalibrationPoints({
                                    center: null,
                                    top: null,
                                    bottom: null,
                                    left: null,
                                    right: null
                                });
                                setIsCalibrated(false);
                                setClickMode(false);
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    });
                }
            };

            const handleImageClick = (e) => {
                if (!imageCanvasRef.current) return;
                
                const canvas = imageCanvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                if (calibrationMode && calibrationStep < 5) {
                    const currentKey = calibrationSteps[calibrationStep].key;
                    setCalibrationPoints(prev => ({
                        ...prev,
                        [currentKey]: { x, y }
                    }));
                    
                    if (calibrationStep === 4) {
                        setCalibrationMode(false);
                        setIsCalibrated(true);
                        setClickMode(true);
                    } else {
                        setCalibrationStep(calibrationStep + 1);
                    }
                } else if (clickMode && isCalibrated) {
                    if (deleteMode) {
                        // Modo apagar - remover disparo mais próximo
                        const { center, top, bottom, left, right } = calibrationPoints;
                        const scaleYCoord = (bottom.y - top.y) / targetDims.height;
                        const scaleXCoord = (right.x - left.x) / targetDims.width;

                        let closestIndex = -1;
                        let minDistance = Infinity;

                        shots.forEach((shot, index) => {
                            const pixelX = center.x + (shot.x * scaleXCoord);
                            const pixelY = center.y - (shot.y * scaleYCoord);
                            
                            const distance = Math.sqrt(
                                Math.pow(x - pixelX, 2) + Math.pow(y - pixelY, 2)
                            );
                            
                            if (distance < minDistance && distance < 30) { // Raio de 30 pixels para touch
                                minDistance = distance;
                                closestIndex = index;
                            }
                        });

                        if (closestIndex !== -1) {
                            setShots(shots.filter((_, i) => i !== closestIndex));
                            setDeleteMode(false); // Desativar modo apagar após deletar
                        }
                    } else {
                        // Modo adicionar - adicionar novo disparo
                        const coords = pixelToCoordinates(x, y);
                        if (coords) {
                            setShots([...shots, coords]);
                        }
                    }
                }
            };

            const handleImageRightClick = (e) => {
                e.preventDefault(); // Prevenir menu de contexto
                
                if (!imageCanvasRef.current || !isCalibrated || shots.length === 0) return;
                
                const canvas = imageCanvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = (e.clientX - rect.left) * scaleX;
                const clickY = (e.clientY - rect.top) * scaleY;

                // Encontrar o disparo mais próximo do clique
                const { center, top, bottom, left, right } = calibrationPoints;
                const scaleYCoord = (bottom.y - top.y) / targetDims.height;
                const scaleXCoord = (right.x - left.x) / targetDims.width;

                let closestIndex = -1;
                let minDistance = Infinity;

                shots.forEach((shot, index) => {
                    const pixelX = center.x + (shot.x * scaleXCoord);
                    const pixelY = center.y - (shot.y * scaleYCoord);
                    
                    const distance = Math.sqrt(
                        Math.pow(clickX - pixelX, 2) + Math.pow(clickY - pixelY, 2)
                    );
                    
                    if (distance < minDistance && distance < 20) { // Raio de 20 pixels
                        minDistance = distance;
                        closestIndex = index;
                    }
                });

                if (closestIndex !== -1) {
                    // Remover o disparo mais próximo
                    setShots(shots.filter((_, i) => i !== closestIndex));
                }
            };

            const pixelToCoordinates = (pixelX, pixelY) => {
                if (!isCalibrated) return null;

                const { center, top, bottom, left, right } = calibrationPoints;
                const totalHeight = targetDims.height;
                const totalWidth = targetDims.width;
                
                const scaleY = (bottom.y - top.y) / totalHeight;
                const scaleX = (right.x - left.x) / totalWidth;
                const deltaX = pixelX - center.x;
                const deltaY = center.y - pixelY;
                const x = deltaX / scaleX;
                const y = deltaY / scaleY;

                return { x, y };
            };

            const drawImageCanvas = () => {
                try {
                    console.log('drawImageCanvas called');
                    if (!imageCanvasRef.current || !originalImageElement) {
                        console.log('No canvas or image');
                        return;
                    }

                    const canvas = imageCanvasRef.current;
                    const ctx = canvas.getContext('2d');

                    const maxWidth = Math.min(window.innerWidth - 40, 800);
                    const maxHeight = Math.min(window.innerHeight * 0.6, 600);
                    let width = originalImageElement.width;
                    let height = originalImageElement.height;

                    if (width > maxWidth || height > maxHeight) {
                        const ratio = Math.min(maxWidth / width, maxHeight / height);
                        width *= ratio;
                        height *= ratio;
                    }

                    canvas.width = width;
                    canvas.height = height;

                    ctx.drawImage(originalImageElement, 0, 0, width, height);

                    ctx.strokeStyle = '#00FF00';
                    ctx.fillStyle = '#00FF00';
                    ctx.lineWidth = 3;

                    Object.entries(calibrationPoints).forEach(([key, point]) => {
                        if (point) {
                            // Apenas cruz (sem círculo)
                            ctx.strokeStyle = '#00FF00';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(point.x - 10, point.y);
                            ctx.lineTo(point.x + 10, point.y);
                            ctx.moveTo(point.x, point.y - 10);
                            ctx.lineTo(point.x, point.y + 10);
                            ctx.stroke();

                            ctx.fillStyle = '#FFFFFF';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.font = 'bold 12px Arial';
                            const labels = {
                                center: 'C',
                                top: 'T',
                                bottom: 'B',
                                left: 'E',
                                right: 'D'
                            };
                            const label = labels[key] || key.substring(0, 1).toUpperCase();
                            ctx.strokeText(label, point.x + 15, point.y - 10);
                            ctx.fillStyle = '#00FF00';
                            ctx.fillText(label, point.x + 15, point.y - 10);
                        }
                    });

                    console.log('Drawing shots:', shots.length);
                    if (isCalibrated && shots.length > 0) {
                        shots.forEach((shot, index) => {
                            console.log(`Drawing shot ${index}:`, shot);
                            const { center, top, bottom, left, right } = calibrationPoints;
                            
                            const scaleY = (bottom.y - top.y) / targetDims.height;
                            const scaleX = (right.x - left.x) / targetDims.width;
                            
                            const pixelX = center.x + (shot.x * scaleX);
                            const pixelY = center.y - (shot.y * scaleY);

                            ctx.fillStyle = '#FF0000';
                            ctx.strokeStyle = '#8B0000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(pixelX, pixelY, 8, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        });
                    }
                    console.log('drawImageCanvas completed');
                } catch (error) {
                    console.error('Error in drawImageCanvas:', error);
                }
            };

            useEffect(() => {
                console.log('useEffect triggered - originalImageElement:', !!originalImageElement, 'shots:', shots.length);
                if (originalImageElement) {
                    drawImageCanvas();
                }
            }, [originalImageElement, calibrationPoints, shots, isCalibrated, targetDims]);

            const resetCalibration = () => {
                setUploadedImage(null);
                setCalibrationMode(false);
                setCalibrationStep(0);
                setCalibrationPoints({
                    center: null,
                    top: null,
                    bottom: null,
                    left: null,
                    right: null
                });
                setIsCalibrated(false);
                setClickMode(false);
            };

            const addShot = () => {
                if (currentX !== '' && currentY !== '') {
                    setShots([...shots, { x: parseFloat(currentX), y: parseFloat(currentY) }]);
                    setCurrentX('');
                    setCurrentY('');
                }
            };

            const removeShot = (index) => {
                setShots(shots.filter((_, i) => i !== index));
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter') {
                    addShot();
                }
            };

            const calculateResults = () => {
                if (shots.length === 0) return null;

                const meanX = shots.reduce((sum, shot) => sum + shot.x, 0) / shots.length;
                const meanY = shots.reduce((sum, shot) => sum + shot.y, 0) / shots.length;

                const angleXRadians = Math.atan((meanX / 100) / distance);
                const angleYRadians = Math.atan((meanY / 100) / distance);
                
                const meanXMils = angleXRadians * 1000;
                const meanYMils = angleYRadians * 1000;

                const n = shots.length;
                const varianceX = shots.reduce((sum, shot) => sum + Math.pow(shot.x - meanX, 2), 0) / (n - 1);
                const varianceY = shots.reduce((sum, shot) => sum + Math.pow(shot.y - meanY, 2), 0) / (n - 1);
                const stdDevX = Math.sqrt(varianceX);
                const stdDevY = Math.sqrt(varianceY);

                const radialDistances = shots.map(shot => 
                    Math.sqrt(Math.pow(shot.x - meanX, 2) + Math.pow(shot.y - meanY, 2))
                );
                const varianceRadial = radialDistances.reduce((sum, d) => sum + Math.pow(d - (radialDistances.reduce((s, v) => s + v, 0) / n), 2), 0) / (n - 1);
                const stdDevRadial = Math.sqrt(varianceRadial);
                
                const stdDevXMils = Math.atan((stdDevX / 100) / distance) * 1000;
                const stdDevYMils = Math.atan((stdDevY / 100) / distance) * 1000;
                const stdDevRadialMils = Math.atan((stdDevRadial / 100) / distance) * 1000;

                return {
                    meanX,
                    meanY,
                    meanXMils,
                    meanYMils,
                    stdDevX,
                    stdDevY,
                    stdDevXMils,
                    stdDevYMils,
                    stdDevRadialMils
                };
            };

            const results = calculateResults();

            // Desenhar alvo principal
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Escala baseada nas dimensões do alvo
                const maxDim = Math.max(targetDims.width, targetDims.height);
                const scale = (width * 0.9) / maxDim;

                ctx.fillStyle = '#d0d0d0';
                ctx.fillRect(0, 0, width, height);

                const targetWidth = targetDims.width * scale;
                const targetHeight = targetDims.height * scale;
                const left = centerX - targetWidth / 2;
                const top = centerY - targetHeight / 2;

                // Desenhar padrão do alvo conforme tipo
                if (targetType === 'a1_vert' || targetType === 'a1_horiz') {
                    // Alvo A1 com dimensões específicas
                    // Fundo branco
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(left, top, targetWidth, targetHeight);
                    
                    // Desenhar quadriculado fino de 10mm (1cm)
                    const gridSizeFine = 1 * scale; // 10mm = 1cm
                    ctx.strokeStyle = '#CCCCCC';
                    ctx.lineWidth = 0.5;
                    
                    // Ajustar início para que o centro esteja em um vértice
                    const startX = centerX % gridSizeFine;
                    const startY = centerY % gridSizeFine;
                    
                    // Linhas verticais finas
                    for (let x = startX; x < width; x += gridSizeFine) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    
                    // Linhas horizontais finas
                    for (let y = startY; y < height; y += gridSizeFine) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                    
                    // Desenhar quadriculado grosso de 100mm (10cm)
                    const gridSizeThick = 10 * scale; // 100mm = 10cm
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1.5;
                    
                    // Linhas verticais grossas (centro no vértice)
                    for (let x = centerX; x < width; x += gridSizeThick) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    for (let x = centerX - gridSizeThick; x >= 0; x -= gridSizeThick) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    
                    // Linhas horizontais grossas (centro no vértice)
                    for (let y = centerY; y < height; y += gridSizeThick) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                    for (let y = centerY - gridSizeThick; y >= 0; y -= gridSizeThick) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                    
                    // Quadrado de 230mm (23cm)
                    const squareSize = 23 * scale;
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(centerX - squareSize/2, centerY - squareSize/2, 
                                   squareSize, squareSize);
                    
                    // Círculo de 200mm (20cm) de diâmetro
                    const outerRadius = 10 * scale; // raio = 100mm = 10cm
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    // Círculo central preto de 60mm (6cm) de diâmetro
                    const innerRadius = 3 * scale; // raio = 30mm = 3cm
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    // Alvo NATO padrão (quadriculado)
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(centerX, top, targetWidth/2, targetHeight/2);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(left, top, targetWidth/2, targetHeight/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(left, centerY, targetWidth/2, targetHeight/2);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX, centerY, targetWidth/2, targetHeight/2);
                }

                // Eixos
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, top);
                ctx.lineTo(centerX, top + targetHeight);
                ctx.moveTo(left, centerY);
                ctx.lineTo(left + targetWidth, centerY);
                ctx.stroke();

                // Desenhar disparos
                shots.forEach(shot => {
                    const x = centerX + shot.x * scale;
                    const y = centerY - shot.y * scale;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#e74c3c';
                    ctx.fill();
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // Ponto médio
                if (results) {
                    const meanX = centerX + results.meanX * scale;
                    const meanY = centerY - results.meanY * scale;
                    
                    ctx.beginPath();
                    ctx.arc(meanX, meanY, 10, 0, 2 * Math.PI);
                    ctx.fillStyle = '#3498db';
                    ctx.fill();
                    ctx.strokeStyle = '#2980b9';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

            }, [shots, results, targetType, customWidth, customHeight]);

            return (
                <div className="min-h-screen" style={{backgroundColor: '#262626'}}>
                    <div className="max-w-7xl mx-auto p-2 sm:p-4">
                        <div className="bg-white rounded-2xl shadow-2xl overflow-hidden">
                            <div style={{backgroundColor: '#E5E6E7'}} className="p-4 sm:p-8 text-center">
                                <div className="flex items-center justify-center mb-2 sm:mb-4">
                                    <img src={ARES_LOGO} alt="ARES Logo" className="h-24 sm:h-40"/>
                                </div>
                                <h1 className="text-2xl sm:text-4xl font-bold" style={{color: '#262626'}}>Cálculo de Dispersão e PMI</h1>
                            </div>

                            <div className="p-3 sm:p-8">
                                {/* Seção Cenário de Teste */}
                                <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200 mb-4 sm:mb-8">
                                    <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                        Cenário de Teste
                                    </h2>
                                    
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        {/* Linha 0: Descrição | Atirador */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Descrição</label>
                                            <input
                                                type="text"
                                                value={descricao}
                                                onChange={(e) => setDescricao(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                                placeholder="Descrição do teste"
                                            />
                                        </div>

                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Atirador</label>
                                            <input
                                                type="text"
                                                value={atirador}
                                                onChange={(e) => setAtirador(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                                placeholder="Nome do atirador"
                                            />
                                        </div>

                                        {/* Linha 1: Sistema | SN */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Sistema</label>
                                            <select
                                                value={sistema}
                                                onChange={(e) => setSistema(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            >
                                                {config.sistema.map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                            {sistema === 'Outro' && (
                                                <input
                                                    type="text"
                                                    value={sistemaOutro}
                                                    onChange={(e) => setSistemaOutro(e.target.value)}
                                                    placeholder="Especifique o sistema"
                                                    className="w-full p-2 border border-gray-300 rounded mt-2"
                                                />
                                            )}
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">SN</label>
                                            <input
                                                type="text"
                                                value={sn}
                                                onChange={(e) => setSn(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                        {/* Linha 2: Armamento | Munição */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Armamento</label>
                                            <select
                                                value={armamento}
                                                onChange={(e) => {
                                                    setArmamento(e.target.value);
                                                    if (e.target.value === 'Outro') {
                                                        setTipoMunicao('Outro');
                                                    } else if (config.municao[e.target.value]) {
                                                        setTipoMunicao(config.municao[e.target.value][0]);
                                                    }
                                                }}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            >
                                                {config.armamento.map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                            {armamento === 'Outro' && (
                                                <input
                                                    type="text"
                                                    value={armamentoOutro}
                                                    onChange={(e) => setArmamentoOutro(e.target.value)}
                                                    placeholder="Especifique o armamento"
                                                    className="w-full p-2 border border-gray-300 rounded mt-2"
                                                />
                                            )}
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Munição</label>
                                            {armamento === 'Outro' ? (
                                                <>
                                                    <input
                                                        type="text"
                                                        value="Outro"
                                                        disabled
                                                        className="w-full p-2 border border-gray-300 rounded bg-gray-100 text-gray-500"
                                                    />
                                                    <input
                                                        type="text"
                                                        value={municaoOutro}
                                                        onChange={(e) => setMunicaoOutro(e.target.value)}
                                                        placeholder="Especifique a munição"
                                                        className="w-full p-2 border border-gray-300 rounded mt-2"
                                                    />
                                                </>
                                            ) : (
                                                <select
                                                    value={tipoMunicao}
                                                    onChange={(e) => setTipoMunicao(e.target.value)}
                                                    className="w-full p-2 border border-gray-300 rounded"
                                                >
                                                    {config.municao[armamento] && config.municao[armamento].map(opt => (
                                                        <option key={opt} value={opt}>{opt}</option>
                                                    ))}
                                                </select>
                                            )}
                                        </div>
                                        
                                        {/* Linha 3: Condições de Teste | Modo */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Condições de Teste</label>
                                            <select
                                                value={condicoesTeste}
                                                onChange={(e) => setCondicoesTeste(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            >
                                                {config.condicoes_teste.map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                            {condicoesTeste === 'Movimento' && (
                                                <textarea
                                                    value={cenarioMovimento}
                                                    onChange={(e) => setCenarioMovimento(e.target.value)}
                                                    placeholder="Descreva o cenário de movimento"
                                                    className="w-full p-2 border border-gray-300 rounded mt-2"
                                                    rows="2"
                                                />
                                            )}
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Modo</label>
                                            <input
                                                type="text"
                                                value={modo}
                                                onChange={(e) => setModo(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                        {/* Linha 4: Tipo de Disparo | Quantidade Total de Disparos */}
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Tipo de Disparo</label>
                                            <select
                                                value={tipoDisparo}
                                                onChange={(e) => setTipoDisparo(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            >
                                                {config.tipo_disparo.map(opt => (
                                                    <option key={opt} value={opt}>{opt}</option>
                                                ))}
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">Quantidade Total de Disparos</label>
                                            <input
                                                type="text"
                                                value={qtdDisparos}
                                                onChange={(e) => setQtdDisparos(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        
                                    </div>
                                </div>

                                {/* Seção Parâmetros GJ */}
                                <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200 mb-4 sm:mb-8">
                                    <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                        Parâmetros GJ
                                    </h2>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">GJ Intermitente Az</label>
                                            <input
                                                type="text"
                                                value={gjIntermAz}
                                                onChange={(e) => setGjIntermAz(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">GJ Intermitente Elv</label>
                                            <input
                                                type="text"
                                                value={gjIntermElv}
                                                onChange={(e) => setGjIntermElv(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">GJ Rajada Az</label>
                                            <input
                                                type="text"
                                                value={gjRajadaAz}
                                                onChange={(e) => setGjRajadaAz(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                        <div>
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">GJ Rajada Elv</label>
                                            <input
                                                type="text"
                                                value={gjRajadaElv}
                                                onChange={(e) => setGjRajadaElv(e.target.value)}
                                                className="w-full p-2 border border-gray-300 rounded"
                                            />
                                        </div>
                                    </div>
                                </div>

                                {/* Seção de Tipo de Alvo */}
                                <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200 mb-4 sm:mb-8">
                                    <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                         Configuração do Alvo
                                    </h2>
                                    
                                    <div className="mb-6">
                                        <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                            Tipo de Alvo
                                        </label>
                                        <select
                                            value={targetType}
                                            onChange={(e) => {
                                                setTargetType(e.target.value);
                                                // Reset calibração ao mudar tipo
                                                setCalibrationMode(false);
                                                setIsCalibrated(false);
                                                setCalibrationPoints({
                                                    center: null,
                                                    top: null,
                                                    bottom: null,
                                                    left: null,
                                                    right: null
                                                });
                                            }}
                                            className="w-full p-3 border-2 border-gray-300 rounded-lg text-lg"
                                            style={{color: '#262626', fontWeight: '600'}}
                                        >
                                            <option value="otan_230">OTAN 2,3m x 2,3m (230cm x 230cm)</option>
                                            <option value="otan_side">OTAN Side 4,6m x 2,3m (460cm x 230cm)</option>
                                            <option value="a1_vert">Folha A1 - Vertical (59,4cm x 84,1cm)</option>
                                            <option value="a1_horiz">Folha A1 - Horizontal (84,1cm x 59,4cm)</option>
                                            <option value="custom">Customizado</option>
                                        </select>
                                    </div>

                                    {targetType === 'custom' && (
                                        <div className="grid grid-cols-2 gap-4 mb-6">
                                            <div>
                                                <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                    Largura (cm)
                                                </label>
                                                <input
                                                    type="number"
                                                    value={customWidth}
                                                    onChange={(e) => setCustomWidth(parseFloat(e.target.value) || 230)}
                                                    className="w-full p-3 border-2 border-gray-300 rounded-lg"
                                                    step="0.1"
                                                    min="10"
                                                />
                                            </div>
                                            <div>
                                                <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                    Altura (cm)
                                                </label>
                                                <input
                                                    type="number"
                                                    value={customHeight}
                                                    onChange={(e) => setCustomHeight(parseFloat(e.target.value) || 230)}
                                                    className="w-full p-3 border-2 border-gray-300 rounded-lg"
                                                    step="0.1"
                                                    min="10"
                                                />
                                            </div>
                                        </div>
                                    )}

                                    <div className="bg-blue-50 p-4 rounded-lg border border-blue-200">
                                        <p className="text-sm text-blue-900">
                                            <strong>Alvo selecionado:</strong> {targetDims.width.toFixed(1)}cm (largura) x {targetDims.height.toFixed(1)}cm (altura)
                                        </p>
                                        <p className="text-xs text-blue-700 mt-2">
                                            Limites: X = ±{halfWidth.toFixed(1)}cm | Y = ±{halfHeight.toFixed(1)}cm
                                        </p>
                                    </div>
                                </div>

                                {/* Upload e Calibração */}
                                <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200 mb-4 sm:mb-8">
                                    <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                         Registro por Foto do Alvo
                                    </h2>
                                    
                                    <div className="mb-6">
                                        <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                            Upload da foto do alvo
                                        </label>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={handleImageUpload}
                                            className="w-full p-3 border-2 border-gray-300 rounded-lg"
                                        />
                                    </div>

                                    {uploadedImage && (
                                        <div>
                                            {calibrationMode && (
                                                <div className="mb-3 p-3 bg-gray-50 border-2 border-gray-300 rounded-lg">
                                                    <h3 className="font-bold text-gray-800 mb-1 text-sm sm:text-base">
                                                         Calibração - Passo {calibrationStep + 1} de 5
                                                    </h3>
                                                    <p className="text-gray-900 text-xs sm:text-sm">
                                                        Clique no ponto: <strong>{calibrationSteps[calibrationStep].label}</strong>
                                                    </p>
                                                </div>
                                            )}

                                            {isCalibrated && clickMode && (
                                                <div className="mb-3 p-3 bg-gray-50 border-2 border-gray-300 rounded-lg">
                                                    <h3 className="font-bold text-gray-800 mb-1 text-sm sm:text-base">
                                                         Calibração Concluída!
                                                    </h3>
                                                    {deleteMode ? (
                                                        <p className="text-red-400 font-bold text-sm sm:text-lg mb-2">
                                                             MODO APAGAR - Clique no disparo
                                                        </p>
                                                    ) : (
                                                        <p className="text-gray-800 mb-2 text-xs sm:text-sm">
                                                            <strong>Clique:</strong> Marcar impacto<br/>
                                                            <strong>Clique direito (PC):</strong> Apagar impacto
                                                        </p>
                                                    )}
                                                    <div className="flex gap-2 mt-2 flex-wrap">
                                                        <button
                                                            onClick={() => setClickMode(!clickMode)}
                                                            className="px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg font-semibold text-white text-xs sm:text-sm"
                                                            style={{background: clickMode ? '#f39c12' : '#262626'}}
                                                        >
                                                            {clickMode ? ' Pausar' : ' Retomar'}
                                                        </button>
                                                        <button
                                                            onClick={() => setDeleteMode(!deleteMode)}
                                                            className={`px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg font-semibold text-white text-xs sm:text-sm ${deleteMode ? 'bg-gray-50' : 'bg-zinc-600'}`}
                                                        >
                                                            {deleteMode ? ' Cancelar' : ' Apagar'}
                                                        </button>
                                                        <button
                                                            onClick={resetCalibration}
                                                            className="px-3 py-1.5 sm:px-4 sm:py-2 bg-zinc-600 hover:bg-zinc-500 text-white rounded-lg font-semibold text-xs sm:text-sm"
                                                        >
                                                             Recalibrar
                                                        </button>
                                                    </div>
                                                </div>
                                            )}

                                            <div className="flex justify-center">
                                                <canvas
                                                    ref={imageCanvasRef}
                                                    onClick={handleImageClick}
                                                    onContextMenu={handleImageRightClick}
                                                    className="border-4 rounded-lg shadow-lg max-w-full"
                                                    style={{
                                                        borderColor: '#262626',
                                                        cursor: deleteMode ? 'not-allowed' : 'crosshair'
                                                    }}
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>

                                    {/* Entrada Manual */}
                                    <div className="bg-white p-3 sm:p-6 rounded-xl border-2 border-gray-200 mb-4 sm:mb-8">
                                        <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                            Entrada Manual
                                        </h2>
                                        
                                        <div className="mb-6">
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                Distância (metros)
                                            </label>
                                            <input
                                                type="number"
                                                value={distance}
                                                onChange={(e) => setDistance(parseFloat(e.target.value) || 0)}
                                                className="w-full p-3 border-2 border-gray-300 rounded-lg text-lg"
                                                step="1"
                                                min="1"
                                            />
                                        </div>

                                        <div className="mb-6">
                                            <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                Adicionar disparo (±{halfWidth.toFixed(1)}cm x ±{halfHeight.toFixed(1)}cm)
                                            </label>
                                            <div className="grid grid-cols-2 gap-3 mb-3">
                                                <input
                                                    type="number"
                                                    placeholder="X"
                                                    value={currentX}
                                                    onChange={(e) => setCurrentX(e.target.value)}
                                                    onKeyPress={handleKeyPress}
                                                    className="p-3 border-2 border-gray-300 rounded-lg"
                                                    step="0.1"
                                                />
                                                <input
                                                    type="number"
                                                    placeholder="Y"
                                                    value={currentY}
                                                    onChange={(e) => setCurrentY(e.target.value)}
                                                    onKeyPress={handleKeyPress}
                                                    className="p-3 border-2 border-gray-300 rounded-lg"
                                                    step="0.1"
                                                />
                                            </div>
                                            <button 
                                                onClick={addShot}
                                                className="w-full text-white py-3 rounded-lg font-semibold"
                                                style={{background: '#262626'}}
                                            >
                                                + Adicionar
                                            </button>
                                        </div>

                                        {shots.length > 0 && (
                                            <div>
                                                <label className="block mb-2 font-semibold text-gray-800 text-sm">
                                                    Disparos ({shots.length})
                                                </label>
                                                <div className="max-h-80 overflow-y-auto bg-white rounded-lg border-2 border-gray-300">
                                                    <table className="w-full text-sm">
                                                        <thead className="bg-gray-100 sticky top-0">
                                                            <tr>
                                                                <th className="px-3 py-2">#</th>
                                                                <th className="px-3 py-2">X(cm)</th>
                                                                <th className="px-3 py-2">Y(cm)</th>
                                                                <th className="px-3 py-2">X(mils)</th>
                                                                <th className="px-3 py-2">Y(mils)</th>
                                                                <th className="px-3 py-2"></th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {shots.map((shot, index) => {
                                                                const xMils = Math.atan((shot.x / 100) / distance) * 1000;
                                                                const yMils = Math.atan((shot.y / 100) / distance) * 1000;
                                                                return (
                                                                    <tr key={index} className="border-b hover:bg-white">
                                                                        <td className="px-3 py-2 text-center">{index + 1}</td>
                                                                        <td className="px-3 py-2 text-center">{shot.x.toFixed(1)}</td>
                                                                        <td className="px-3 py-2 text-center">{shot.y.toFixed(1)}</td>
                                                                        <td className="px-3 py-2 text-center font-medium" style={{color: '#262626'}}>{xMils.toFixed(2)}</td>
                                                                        <td className="px-3 py-2 text-center font-medium" style={{color: '#262626'}}>{yMils.toFixed(2)}</td>
                                                                        <td className="px-3 py-2 text-center">
                                                                            <button 
                                                                                onClick={() => removeShot(index)}
                                                                                className="bg-zinc-600 hover:bg-zinc-500 text-white px-2 py-1 rounded text-xs font-bold"
                                                                            >
                                                                                ×
                                                                            </button>
                                                                        </td>
                                                                    </tr>
                                                                );
                                                            })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                                <button 
                                                    onClick={clearAll}
                                                    className="w-full mt-4 bg-white0 text-white py-3 rounded-lg font-semibold"
                                                >
                                                    Limpar
                                                </button>
                                            </div>
                                        )}
                                    </div>


                                {/* Visualização */}
                                {shots.length > 0 && (
                                    <div className="mt-4 sm:mt-8">
                                        <h2 className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-6 pb-2 sm:pb-3" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                             Visualização do Alvo
                                        </h2>
                                        
                                        {/* Alvo Principal + Resultados */}
                                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-8 mb-6 items-start">
                                            <div>
                                                <p className="text-gray-600 mb-3 text-sm font-semibold">Alvo Real - {distance}m</p>
                                                <canvas
                                                    ref={canvasRef}
                                                    width={450}
                                                    height={450}
                                                    className="bg-white rounded-lg shadow-lg mx-auto"
                                                    style={{maxWidth: '450px', width: '100%', height: 'auto'}}
                                                />
                                            </div>
                                            <div className="bg-white p-3 sm:p-4 rounded-xl border-2 border-gray-200">
                                                <h3 className="text-lg sm:text-xl font-semibold mb-3 pb-2" style={{color: '#A6A8AA', borderBottom: '2px solid #E5E6E7'}}>
                                                    Resultados
                                                </h3>
                                                {results ? (
                                                    <table className="w-full text-sm">
                                                        <tbody>
                                                            <tr className="bg-gray-50">
                                                                <td colSpan="2" className="px-3 py-2 font-semibold text-gray-800">Ponto Médio</td>
                                                            </tr>
                                                            <tr className="border-b">
                                                                <td className="px-3 py-2">X</td>
                                                                <td className="px-3 py-2 text-right font-bold">{results.meanX.toFixed(2)} cm</td>
                                                            </tr>
                                                            <tr className="border-b">
                                                                <td className="px-3 py-2">Y</td>
                                                                <td className="px-3 py-2 text-right font-bold">{results.meanY.toFixed(2)} cm</td>
                                                            </tr>
                                                            <tr className="bg-gray-50">
                                                                <td colSpan="2" className="px-3 py-2 font-semibold text-gray-800">Em Mils</td>
                                                            </tr>
                                                            <tr className="border-b">
                                                                <td className="px-3 py-2">Horizontal</td>
                                                                <td className="px-3 py-2 text-right font-bold">{results.meanXMils.toFixed(2)} mils</td>
                                                            </tr>
                                                            <tr className="border-b">
                                                                <td className="px-3 py-2">Vertical</td>
                                                                <td className="px-3 py-2 text-right font-bold">{results.meanYMils.toFixed(2)} mils</td>
                                                            </tr>
                                                            <tr className="bg-gray-50">
                                                                <td colSpan="2" className="px-3 py-2 font-semibold text-gray-800">Desvio Padrão</td>
                                                            </tr>
                                                            <tr className="border-b">
                                                                <td className="px-3 py-2">Horizontal</td>
                                                                <td className="px-3 py-2 text-right font-bold">{results.stdDevXMils.toFixed(2)} mils</td>
                                                            </tr>
                                                            <tr className="border-b">
                                                                <td className="px-3 py-2">Vertical</td>
                                                                <td className="px-3 py-2 text-right font-bold">{results.stdDevYMils.toFixed(2)} mils</td>
                                                            </tr>
                                                            <tr>
                                                                <td className="px-3 py-2">Radial</td>
                                                                <td className="px-3 py-2 text-right font-bold">{results.stdDevRadialMils.toFixed(2)} mils</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                ) : (
                                                    <div className="text-center py-8 text-gray-800">
                                                        <p className="text-sm">Adicione disparos</p>
                                                    </div>
                                                )}
                                            </div>
                                        </div>

                                        {/* Simulações - Pequenas */}
                                        <div className="mt-6">
                                            <p className="text-gray-600 mb-3 text-sm font-semibold">
                                                Simulações em Diferentes Distâncias (Alvo OTAN 2,3m x 2,3m)
                                            </p>
                                            <div className="grid grid-cols-2 lg:grid-cols-4 gap-2 sm:gap-3">
                                                {[100, 500, 1000, 1500].map(d => (
                                                    <DistanceSimulation 
                                                        key={d}
                                                        distance={d}
                                                        shots={shots}
                                                        results={results}
                                                        currentDistance={distance}
                                                    />
                                                ))}
                                            </div>
                                        </div>

                                        <div className="mt-6 sm:mt-8">
                                            <button
                                                onClick={generatePDF}
                                                className="w-full py-3 sm:py-5 text-white rounded-xl font-bold text-base sm:text-xl transition-all transform hover:-translate-y-1 hover:shadow-2xl flex items-center justify-center gap-2 sm:gap-3"
                                                style={{background: 'linear-gradient(to right, #262626, #262626)'}}
                                            >
                                                <span className="text-xl sm:text-2xl"></span>
                                                <span>Gerar Relatório em PDF</span>
                                            </button>
                                            <p className="text-center text-gray-600 text-xs sm:text-sm mt-2 sm:mt-3">
                                                Relatório completo com dados balísticos e visualizações
                                            </p>
                                            <button
                                                onClick={clearAll}
                                                className="w-full mt-3 py-3 sm:py-4 text-white rounded-xl font-bold text-base sm:text-lg transition-all transform hover:-translate-y-1 hover:shadow-2xl flex items-center justify-center gap-2 sm:gap-3"
                                                style={{background: 'linear-gradient(to right, #991b1b, #b91c1c)'}}
                                            >
                                                <span>Limpar Tudo</span>
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((reg) => console.log('Service Worker registered:', reg.scope))
                    .catch((err) => console.log('Service Worker registration failed:', err));
            });
        }
    </script>
</body>
</html>